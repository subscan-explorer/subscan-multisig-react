import type { Bytes, Compact, Option, U256, Vec, bool, u16, u32, u64, u8 } from '@polkadot/types';
import type { AnyNumber } from '@polkadot/types/types';
import type { EthereumBlockNumber, EthereumHeader, EthereumReceiptProof, EthereumReceiptProofThing, EthereumRelayHeaderParcel, EthereumRelayProofs, KtonBalance, MMRProof, OtherAddress, OtherSignature, RedeemFor, RelayAuthoritySignature, RelayAuthoritySigner, RingBalance, StakingBalanceT, TsInMs } from '@darwinia/types/interfaces/darwiniaInject';
import type { RelayAffirmationId } from '@darwinia/types/interfaces/relayerGame';
import type { BabeEquivocationProof } from '@polkadot/types/interfaces/babe';
import type { EthereumAddress } from '@polkadot/types/interfaces/claims';
import type { MemberCount, ProposalIndex } from '@polkadot/types/interfaces/collective';
import type { AccountVote, Conviction, PropIndex, Proposal, ReferendumIndex } from '@polkadot/types/interfaces/democracy';
import type { Renouncing } from '@polkadot/types/interfaces/elections';
import type { EthTransaction } from '@polkadot/types/interfaces/eth';
import type { Extrinsic, Signature } from '@polkadot/types/interfaces/extrinsics';
import type { GrandpaEquivocationProof, KeyOwnerProof } from '@polkadot/types/interfaces/grandpa';
import type { Heartbeat } from '@polkadot/types/interfaces/imOnline';
import type { ProxyType } from '@polkadot/types/interfaces/proxy';
import type { AccountId, Balance, BalanceOf, BlockNumber, Call, CallHashOf, ChangesTrieConfiguration, H160, H256, Hash, Header, KeyValue, LookupSource, Moment, Perbill, Percent, Weight } from '@polkadot/types/interfaces/runtime';
import type { Period, Priority } from '@polkadot/types/interfaces/scheduler';
import type { Keys } from '@polkadot/types/interfaces/session';
import type { CompactAssignments, ElectionScore, ElectionSize, EraIndex, RewardDestination, ValidatorIndex, ValidatorPrefs } from '@polkadot/types/interfaces/staking';
import type { Key } from '@polkadot/types/interfaces/system';
import type { BountyIndex } from '@polkadot/types/interfaces/treasury';
import type { VestingInfo } from '@polkadot/types/interfaces/vesting';
import type { ApiTypes, SubmittableExtrinsic } from '@polkadot/api/types';
declare module '@polkadot/api/types/submittable' {
    interface AugmentedSubmittables<ApiType> {
        authorship: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Provide a set of uncles.
             **/
            setUncles: AugmentedSubmittable<(newUncles: Vec<Header> | (Header | {
                parentHash?: any;
                number?: any;
                stateRoot?: any;
                extrinsicsRoot?: any;
                digest?: any;
            } | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<Header>]>;
        };
        babe: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Report authority equivocation/misbehavior. This method will verify
             * the equivocation proof and validate the given key ownership proof
             * against the extracted offender. If both are valid, the offence will
             * be reported.
             **/
            reportEquivocation: AugmentedSubmittable<(equivocationProof: BabeEquivocationProof | {
                offender?: any;
                slotNumber?: any;
                firstHeader?: any;
                secondHeader?: any;
            } | string | Uint8Array, keyOwnerProof: KeyOwnerProof | {
                session?: any;
                trieNodes?: any;
                validatorCount?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [BabeEquivocationProof, KeyOwnerProof]>;
            /**
             * Report authority equivocation/misbehavior. This method will verify
             * the equivocation proof and validate the given key ownership proof
             * against the extracted offender. If both are valid, the offence will
             * be reported.
             * This extrinsic must be called unsigned and it is expected that only
             * block authors will call it (validated in `ValidateUnsigned`), as such
             * if the block author is defined it will be defined as the equivocation
             * reporter.
             **/
            reportEquivocationUnsigned: AugmentedSubmittable<(equivocationProof: BabeEquivocationProof | {
                offender?: any;
                slotNumber?: any;
                firstHeader?: any;
                secondHeader?: any;
            } | string | Uint8Array, keyOwnerProof: KeyOwnerProof | {
                session?: any;
                trieNodes?: any;
                validatorCount?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [BabeEquivocationProof, KeyOwnerProof]>;
        };
        balances: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Exactly as `transfer`, except the origin must be root and the source account may be
             * specified.
             * # <weight>
             * - Same as transfer, but additional read and write because the source account is
             * not assumed to be in the overlay.
             * # </weight>
             **/
            forceTransfer: AugmentedSubmittable<(source: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, dest: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, value: Compact<Balance> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [LookupSource, LookupSource, Compact<Balance>]>;
            /**
             * Set the balances of a given account.
             *
             * This will alter `FreeBalance` and `ReservedBalance` in storage. it will
             * also decrease the total issuance of the system (`TotalIssuance`).
             * If the new free or reserved balance is below the existential deposit,
             * it will reset the account nonce (`frame_system::AccountNonce`).
             *
             * The dispatch origin for this call is `root`.
             *
             * # <weight>
             * - Independent of the arguments.
             * - Contains a limited number of reads and writes.
             * # </weight>
             **/
            setBalance: AugmentedSubmittable<(who: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, newFree: Compact<Balance> | AnyNumber | Uint8Array, newReserved: Compact<Balance> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [LookupSource, Compact<Balance>, Compact<Balance>]>;
            /**
             * Transfer some liquid free balance to another account.
             *
             * `transfer` will set the `FreeBalance` of the sender and receiver.
             * It will decrease the total issuance of the system by the `TransferFee`.
             * If the sender's account is below the existential deposit as a result
             * of the transfer, the account will be reaped.
             *
             * The dispatch origin for this call must be `Signed` by the transactor.
             *
             * # <weight>
             * - Dependent on arguments but not critical, given proper implementations for
             * input config types. See related functions below.
             * - It contains a limited number of reads and writes internally and no complex computation.
             *
             * Related functions:
             *
             * - `ensure_can_withdraw` is always called internally but has a bounded complexity.
             * - Transferring balances to accounts that did not exist before will cause
             * `T::OnNewAccount::on_new_account` to be called.
             * - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.
             * - `transfer_keep_alive` works the same way as `transfer`, but has an additional
             * check that the transfer will not kill the origin account.
             *
             * # </weight>
             **/
            transfer: AugmentedSubmittable<(dest: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, value: Compact<Balance> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [LookupSource, Compact<Balance>]>;
            /**
             * Same as the [`transfer`] call, but with a check that the transfer will not kill the
             * origin account.
             *
             * 99% of the time you want [`transfer`] instead.
             *
             * [`transfer`]: struct.Module.html#method.transfer
             **/
            transferKeepAlive: AugmentedSubmittable<(dest: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, value: Compact<Balance> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [LookupSource, Compact<Balance>]>;
        };
        claims: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Make a claim to collect your DOTs.
             *
             * The dispatch origin for this call must be _None_.
             *
             * Unsigned Validation:
             * A call to claim is deemed valid if the signature provided matches
             * the expected signed message of:
             *
             * > Ethereum Signed Message:
             * > (configured prefix string)(address)
             *
             * and `address` matches the `dest` account.
             *
             * Parameters:
             * - `dest`: The destination account to payout the claim.
             * - `ethereum_signature`: The signature of an ethereum signed message
             * matching the format described above.
             *
             * <weight>
             * The weight of this call is invariant over the input parameters.
             * - One `eth_recover` operation which involves a keccak hash and a
             * ecdsa recover.
             * - Three storage reads to check if a claim exists for the user, to
             * get the current pot size, to see if there exists a vesting schedule.
             * - Up to one storage write for adding a new vesting schedule.
             * - One `deposit_creating` Currency call.
             * - One storage write to update the total.
             * - Two storage removals for vesting and claims information.
             * - One deposit event.
             *
             * Total Complexity: O(1)
             * ----------------------------
             * Base Weight: 269.7 µs
             * DB Weight:
             * - Read: Claims
             * - Write: Account, Claims
             * Validate Unsigned: +188.7 µs
             * </weight>
             **/
            claim: AugmentedSubmittable<(dest: AccountId | string | Uint8Array, signature: OtherSignature | {
                Eth: any;
            } | {
                Tron: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId, OtherSignature]>;
            /**
             * Mint a new claim to collect DOTs.
             *
             * The dispatch origin for this call must be _Root_.
             *
             * Parameters:
             * - `who`: The Ethereum address allowed to collect this claim.
             * - `value`: The number of DOTs that will be claimed.
             * - `vesting_schedule`: An optional vesting schedule for these DOTs.
             *
             * <weight>
             * The weight of this call is invariant over the input parameters.
             * - One storage mutate to increase the total claims available.
             * - One storage write to add a new claim.
             * - Up to one storage write to add a new vesting schedule.
             *
             * Total Complexity: O(1)
             * ---------------------
             * Base Weight: 10.46 µs
             * DB Weight:
             * - Reads:
             * - Writes: Account, Claims
             * - Maybe Write: Vesting, Statement
             * </weight>
             **/
            mintClaim: AugmentedSubmittable<(who: OtherAddress | {
                Eth: any;
            } | {
                Tron: any;
            } | string | Uint8Array, value: RingBalance | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [OtherAddress, RingBalance]>;
            moveClaim: AugmentedSubmittable<(old: OtherAddress | {
                Eth: any;
            } | {
                Tron: any;
            } | string | Uint8Array, updated: OtherAddress | {
                Eth: any;
            } | {
                Tron: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [OtherAddress, OtherAddress]>;
        };
        council: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Close a vote that is either approved, disapproved or whose voting period has ended.
             *
             * May be called by any signed account in order to finish voting and close the proposal.
             *
             * If called before the end of the voting period it will only close the vote if it is
             * has enough votes to be approved or disapproved.
             *
             * If called after the end of the voting period abstentions are counted as rejections
             * unless there is a prime member set and the prime member cast an approval.
             *
             * If the close operation completes successfully with disapproval, the transaction fee will
             * be waived. Otherwise execution of the approved operation will be charged to the caller.
             *
             * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.
             * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
             * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
             *
             * # <weight>
             * ## Weight
             * - `O(B + M + P1 + P2)` where:
             * - `B` is `proposal` size in bytes (length-fee-bounded)
             * - `M` is members-count (code- and governance-bounded)
             * - `P1` is the complexity of `proposal` preimage.
             * - `P2` is proposal-count (code-bounded)
             * - DB:
             * - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
             * - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)
             * - any mutations done while executing `proposal` (`P1`)
             * - up to 3 events
             * # </weight>
             **/
            close: AugmentedSubmittable<(proposalHash: Hash | string | Uint8Array, index: Compact<ProposalIndex> | AnyNumber | Uint8Array, proposalWeightBound: Compact<Weight> | AnyNumber | Uint8Array, lengthBound: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash, Compact<ProposalIndex>, Compact<Weight>, Compact<u32>]>;
            /**
             * Disapprove a proposal, close, and remove it from the system, regardless of its current state.
             *
             * Must be called by the Root origin.
             *
             * Parameters:
             * * `proposal_hash`: The hash of the proposal that should be disapproved.
             *
             * # <weight>
             * Complexity: O(P) where P is the number of max proposals
             * DB Weight:
             * * Reads: Proposals
             * * Writes: Voting, Proposals, ProposalOf
             * # </weight>
             **/
            disapproveProposal: AugmentedSubmittable<(proposalHash: Hash | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash]>;
            /**
             * Dispatch a proposal from a member using the `Member` origin.
             *
             * Origin must be a member of the collective.
             *
             * # <weight>
             * ## Weight
             * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
             * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
             * - 1 event
             * # </weight>
             **/
            execute: AugmentedSubmittable<(proposal: Proposal | {
                callIndex?: any;
                args?: any;
            } | string | Uint8Array, lengthBound: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Proposal, Compact<u32>]>;
            /**
             * Add a new proposal to either be voted on or executed directly.
             *
             * Requires the sender to be member.
             *
             * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
             * or put up for voting.
             *
             * # <weight>
             * ## Weight
             * - `O(B + M + P1)` or `O(B + M + P2)` where:
             * - `B` is `proposal` size in bytes (length-fee-bounded)
             * - `M` is members-count (code- and governance-bounded)
             * - branching is influenced by `threshold` where:
             * - `P1` is proposal execution complexity (`threshold < 2`)
             * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
             * - DB:
             * - 1 storage read `is_member` (codec `O(M)`)
             * - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
             * - DB accesses influenced by `threshold`:
             * - EITHER storage accesses done by `proposal` (`threshold < 2`)
             * - OR proposal insertion (`threshold <= 2`)
             * - 1 storage mutation `Proposals` (codec `O(P2)`)
             * - 1 storage mutation `ProposalCount` (codec `O(1)`)
             * - 1 storage write `ProposalOf` (codec `O(B)`)
             * - 1 storage write `Voting` (codec `O(M)`)
             * - 1 event
             * # </weight>
             **/
            propose: AugmentedSubmittable<(threshold: Compact<MemberCount> | AnyNumber | Uint8Array, proposal: Proposal | {
                callIndex?: any;
                args?: any;
            } | string | Uint8Array, lengthBound: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<MemberCount>, Proposal, Compact<u32>]>;
            /**
             * Set the collective's membership.
             *
             * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
             * - `prime`: The prime member whose vote sets the default.
             * - `old_count`: The upper bound for the previous number of members in storage.
             * Used for weight estimation.
             *
             * Requires root origin.
             *
             * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
             * the weight estimations rely on it to estimate dispatchable weight.
             *
             * # <weight>
             * ## Weight
             * - `O(MP + N)` where:
             * - `M` old-members-count (code- and governance-bounded)
             * - `N` new-members-count (code- and governance-bounded)
             * - `P` proposals-count (code-bounded)
             * - DB:
             * - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members
             * - 1 storage read (codec `O(P)`) for reading the proposals
             * - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal
             * - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one
             * # </weight>
             **/
            setMembers: AugmentedSubmittable<(newMembers: Vec<AccountId> | (AccountId | string | Uint8Array)[], prime: Option<AccountId> | null | object | string | Uint8Array, oldCount: MemberCount | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Vec<AccountId>, Option<AccountId>, MemberCount]>;
            /**
             * Add an aye or nay vote for the sender to the given proposal.
             *
             * Requires the sender to be a member.
             *
             * Transaction fees will be waived if the member is voting on any particular proposal
             * for the first time and the call is successful. Subsequent vote changes will charge a fee.
             * # <weight>
             * ## Weight
             * - `O(M)` where `M` is members-count (code- and governance-bounded)
             * - DB:
             * - 1 storage read `Members` (codec `O(M)`)
             * - 1 storage mutation `Voting` (codec `O(M)`)
             * - 1 event
             * # </weight>
             **/
            vote: AugmentedSubmittable<(proposal: Hash | string | Uint8Array, index: Compact<ProposalIndex> | AnyNumber | Uint8Array, approve: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash, Compact<ProposalIndex>, bool]>;
        };
        democracy: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Permanently place a proposal into the blacklist. This prevents it from ever being
             * proposed again.
             *
             * If called on a queued public or external proposal, then this will result in it being
             * removed. If the `ref_index` supplied is an active referendum with the proposal hash,
             * then it will be cancelled.
             *
             * The dispatch origin of this call must be `BlacklistOrigin`.
             *
             * - `proposal_hash`: The proposal hash to blacklist permanently.
             * - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
             * cancelled.
             *
             * Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
             * reasonable value).
             **/
            blacklist: AugmentedSubmittable<(proposalHash: Hash | string | Uint8Array, maybeRefIndex: Option<ReferendumIndex> | null | object | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash, Option<ReferendumIndex>]>;
            /**
             * Remove a proposal.
             *
             * The dispatch origin of this call must be `CancelProposalOrigin`.
             *
             * - `prop_index`: The index of the proposal to cancel.
             *
             * Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
             **/
            cancelProposal: AugmentedSubmittable<(propIndex: Compact<PropIndex> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<PropIndex>]>;
            /**
             * Cancel a proposal queued for enactment.
             *
             * The dispatch origin of this call must be _Root_.
             *
             * - `which`: The index of the referendum to cancel.
             *
             * Weight: `O(D)` where `D` is the items in the dispatch queue. Weighted as `D = 10`.
             **/
            cancelQueued: AugmentedSubmittable<(which: ReferendumIndex | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [ReferendumIndex]>;
            /**
             * Remove a referendum.
             *
             * The dispatch origin of this call must be _Root_.
             *
             * - `ref_index`: The index of the referendum to cancel.
             *
             * # Weight: `O(1)`.
             **/
            cancelReferendum: AugmentedSubmittable<(refIndex: Compact<ReferendumIndex> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<ReferendumIndex>]>;
            /**
             * Clears all public proposals.
             *
             * The dispatch origin of this call must be _Root_.
             *
             * Weight: `O(1)`.
             **/
            clearPublicProposals: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            /**
             * Delegate the voting power (with some given conviction) of the sending account.
             *
             * The balance delegated is locked for as long as it's delegated, and thereafter for the
             * time appropriate for the conviction's lock period.
             *
             * The dispatch origin of this call must be _Signed_, and the signing account must either:
             * - be delegating already; or
             * - have no voting activity (if there is, then it will need to be removed/consolidated
             * through `reap_vote` or `unvote`).
             *
             * - `to`: The account whose voting the `target` account's voting power will follow.
             * - `conviction`: The conviction that will be attached to the delegated votes. When the
             * account is undelegated, the funds will be locked for the corresponding period.
             * - `balance`: The amount of the account's balance to be used in delegating. This must
             * not be more than the account's current balance.
             *
             * Emits `Delegated`.
             *
             * Weight: `O(R)` where R is the number of referendums the voter delegating to has
             * voted on. Weight is charged as if maximum votes.
             **/
            delegate: AugmentedSubmittable<(to: AccountId | string | Uint8Array, conviction: Conviction | 'None' | 'Locked1x' | 'Locked2x' | 'Locked3x' | 'Locked4x' | 'Locked5x' | 'Locked6x' | number | Uint8Array, balance: BalanceOf | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId, Conviction, BalanceOf]>;
            /**
             * Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
             * referendum.
             *
             * The dispatch origin of this call must be `CancellationOrigin`.
             *
             * -`ref_index`: The index of the referendum to cancel.
             *
             * Weight: `O(1)`.
             **/
            emergencyCancel: AugmentedSubmittable<(refIndex: ReferendumIndex | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [ReferendumIndex]>;
            /**
             * Enact a proposal from a referendum. For now we just make the weight be the maximum.
             **/
            enactProposal: AugmentedSubmittable<(proposalHash: Hash | string | Uint8Array, index: ReferendumIndex | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash, ReferendumIndex]>;
            /**
             * Schedule a referendum to be tabled once it is legal to schedule an external
             * referendum.
             *
             * The dispatch origin of this call must be `ExternalOrigin`.
             *
             * - `proposal_hash`: The preimage hash of the proposal.
             *
             * Weight: `O(V)` with V number of vetoers in the blacklist of proposal.
             * Decoding vec of length V. Charged as maximum
             **/
            externalPropose: AugmentedSubmittable<(proposalHash: Hash | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash]>;
            /**
             * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
             * schedule an external referendum.
             *
             * The dispatch of this call must be `ExternalDefaultOrigin`.
             *
             * - `proposal_hash`: The preimage hash of the proposal.
             *
             * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
             * pre-scheduled `external_propose` call.
             *
             * Weight: `O(1)`
             **/
            externalProposeDefault: AugmentedSubmittable<(proposalHash: Hash | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash]>;
            /**
             * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
             * an external referendum.
             *
             * The dispatch of this call must be `ExternalMajorityOrigin`.
             *
             * - `proposal_hash`: The preimage hash of the proposal.
             *
             * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
             * pre-scheduled `external_propose` call.
             *
             * Weight: `O(1)`
             **/
            externalProposeMajority: AugmentedSubmittable<(proposalHash: Hash | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash]>;
            /**
             * Schedule the currently externally-proposed majority-carries referendum to be tabled
             * immediately. If there is no externally-proposed referendum currently, or if there is one
             * but it is not a majority-carries referendum then it fails.
             *
             * The dispatch of this call must be `FastTrackOrigin`.
             *
             * - `proposal_hash`: The hash of the current external proposal.
             * - `voting_period`: The period that is allowed for voting on this proposal. Increased to
             * `FastTrackVotingPeriod` if too low.
             * - `delay`: The number of block after voting has ended in approval and this should be
             * enacted. This doesn't have a minimum amount.
             *
             * Emits `Started`.
             *
             * Weight: `O(1)`
             **/
            fastTrack: AugmentedSubmittable<(proposalHash: Hash | string | Uint8Array, votingPeriod: BlockNumber | AnyNumber | Uint8Array, delay: BlockNumber | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash, BlockNumber, BlockNumber]>;
            /**
             * Register the preimage for an upcoming proposal. This requires the proposal to be
             * in the dispatch queue. No deposit is needed. When this call is successful, i.e.
             * the preimage has not been uploaded before and matches some imminent proposal,
             * no fee is paid.
             *
             * The dispatch origin of this call must be _Signed_.
             *
             * - `encoded_proposal`: The preimage of a proposal.
             *
             * Emits `PreimageNoted`.
             *
             * Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit).
             **/
            noteImminentPreimage: AugmentedSubmittable<(encodedProposal: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;
            /**
             * Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`.
             **/
            noteImminentPreimageOperational: AugmentedSubmittable<(encodedProposal: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;
            /**
             * Register the preimage for an upcoming proposal. This doesn't require the proposal to be
             * in the dispatch queue but does require a deposit, returned once enacted.
             *
             * The dispatch origin of this call must be _Signed_.
             *
             * - `encoded_proposal`: The preimage of a proposal.
             *
             * Emits `PreimageNoted`.
             *
             * Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit).
             **/
            notePreimage: AugmentedSubmittable<(encodedProposal: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;
            /**
             * Same as `note_preimage` but origin is `OperationalPreimageOrigin`.
             **/
            notePreimageOperational: AugmentedSubmittable<(encodedProposal: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;
            /**
             * Propose a sensitive action to be taken.
             *
             * The dispatch origin of this call must be _Signed_ and the sender must
             * have funds to cover the deposit.
             *
             * - `proposal_hash`: The hash of the proposal preimage.
             * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
             *
             * Emits `Proposed`.
             *
             * Weight: `O(p)`
             **/
            propose: AugmentedSubmittable<(proposalHash: Hash | string | Uint8Array, value: Compact<BalanceOf> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash, Compact<BalanceOf>]>;
            /**
             * Remove an expired proposal preimage and collect the deposit.
             *
             * The dispatch origin of this call must be _Signed_.
             *
             * - `proposal_hash`: The preimage hash of a proposal.
             * - `proposal_length_upper_bound`: an upper bound on length of the proposal.
             * Extrinsic is weighted according to this value with no refund.
             *
             * This will only work after `VotingPeriod` blocks from the time that the preimage was
             * noted, if it's the same account doing it. If it's a different account, then it'll only
             * work an additional `EnactmentPeriod` later.
             *
             * Emits `PreimageReaped`.
             *
             * Weight: `O(D)` where D is length of proposal.
             **/
            reapPreimage: AugmentedSubmittable<(proposalHash: Hash | string | Uint8Array, proposalLenUpperBound: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash, Compact<u32>]>;
            /**
             * Remove a vote for a referendum.
             *
             * If the `target` is equal to the signer, then this function is exactly equivalent to
             * `remove_vote`. If not equal to the signer, then the vote must have expired,
             * either because the referendum was cancelled, because the voter lost the referendum or
             * because the conviction period is over.
             *
             * The dispatch origin of this call must be _Signed_.
             *
             * - `target`: The account of the vote to be removed; this account must have voted for
             * referendum `index`.
             * - `index`: The index of referendum of the vote to be removed.
             *
             * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
             * Weight is calculated for the maximum number of vote.
             **/
            removeOtherVote: AugmentedSubmittable<(target: AccountId | string | Uint8Array, index: ReferendumIndex | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId, ReferendumIndex]>;
            /**
             * Remove a vote for a referendum.
             *
             * If:
             * - the referendum was cancelled, or
             * - the referendum is ongoing, or
             * - the referendum has ended such that
             * - the vote of the account was in opposition to the result; or
             * - there was no conviction to the account's vote; or
             * - the account made a split vote
             * ...then the vote is removed cleanly and a following call to `unlock` may result in more
             * funds being available.
             *
             * If, however, the referendum has ended and:
             * - it finished corresponding to the vote of the account, and
             * - the account made a standard vote with conviction, and
             * - the lock period of the conviction is not over
             * ...then the lock will be aggregated into the overall account's lock, which may involve
             * *overlocking* (where the two locks are combined into a single lock that is the maximum
             * of both the amount locked and the time is it locked for).
             *
             * The dispatch origin of this call must be _Signed_, and the signer must have a vote
             * registered for referendum `index`.
             *
             * - `index`: The index of referendum of the vote to be removed.
             *
             * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
             * Weight is calculated for the maximum number of vote.
             **/
            removeVote: AugmentedSubmittable<(index: ReferendumIndex | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [ReferendumIndex]>;
            /**
             * Signals agreement with a particular proposal.
             *
             * The dispatch origin of this call must be _Signed_ and the sender
             * must have funds to cover the deposit, equal to the original deposit.
             *
             * - `proposal`: The index of the proposal to second.
             * - `seconds_upper_bound`: an upper bound on the current number of seconds on this
             * proposal. Extrinsic is weighted according to this value with no refund.
             *
             * Weight: `O(S)` where S is the number of seconds a proposal already has.
             **/
            second: AugmentedSubmittable<(proposal: Compact<PropIndex> | AnyNumber | Uint8Array, secondsUpperBound: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<PropIndex>, Compact<u32>]>;
            /**
             * Undelegate the voting power of the sending account.
             *
             * Tokens may be unlocked following once an amount of time consistent with the lock period
             * of the conviction with which the delegation was issued.
             *
             * The dispatch origin of this call must be _Signed_ and the signing account must be
             * currently delegating.
             *
             * Emits `Undelegated`.
             *
             * Weight: `O(R)` where R is the number of referendums the voter delegating to has
             * voted on. Weight is charged as if maximum votes.
             **/
            undelegate: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            /**
             * Unlock tokens that have an expired lock.
             *
             * The dispatch origin of this call must be _Signed_.
             *
             * - `target`: The account to remove the lock on.
             *
             * Weight: `O(R)` with R number of vote of target.
             **/
            unlock: AugmentedSubmittable<(target: AccountId | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId]>;
            /**
             * Veto and blacklist the external proposal hash.
             *
             * The dispatch origin of this call must be `VetoOrigin`.
             *
             * - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
             *
             * Emits `Vetoed`.
             *
             * Weight: `O(V + log(V))` where V is number of `existing vetoers`
             **/
            vetoExternal: AugmentedSubmittable<(proposalHash: Hash | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash]>;
            /**
             * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
             * otherwise it is a vote to keep the status quo.
             *
             * The dispatch origin of this call must be _Signed_.
             *
             * - `ref_index`: The index of the referendum to vote for.
             * - `vote`: The vote configuration.
             *
             * Weight: `O(R)` where R is the number of referendums the voter has voted on.
             **/
            vote: AugmentedSubmittable<(refIndex: Compact<ReferendumIndex> | AnyNumber | Uint8Array, vote: AccountVote | {
                Standard: any;
            } | {
                Split: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<ReferendumIndex>, AccountVote]>;
        };
        electionsPhragmen: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
             * deposit of the removed voters are returned.
             *
             * This is an root function to be used only for cleaning the state.
             *
             * The dispatch origin of this call must be root.
             *
             * # <weight>
             * The total number of voters and those that are defunct must be provided as witness data.
             * # </weight>
             **/
            cleanDefunctVoters: AugmentedSubmittable<(numVoters: u32 | AnyNumber | Uint8Array, numDefunct: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32]>;
            /**
             * Remove a particular member from the set. This is effective immediately and the bond of
             * the outgoing member is slashed.
             *
             * If a runner-up is available, then the best runner-up will be removed and replaces the
             * outgoing member. Otherwise, a new phragmen election is started.
             *
             * The dispatch origin of this call must be root.
             *
             * Note that this does not affect the designated block number of the next election.
             *
             * # <weight>
             * If we have a replacement, we use a small weight. Else, since this is a root call and
             * will go into phragmen, we assume full block for now.
             * # </weight>
             **/
            removeMember: AugmentedSubmittable<(who: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, hasReplacement: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [LookupSource, bool]>;
            /**
             * Remove `origin` as a voter.
             *
             * This removes the lock and returns the deposit.
             *
             * The dispatch origin of this call must be signed and be a voter.
             **/
            removeVoter: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            /**
             * Renounce one's intention to be a candidate for the next election round. 3 potential
             * outcomes exist:
             *
             * - `origin` is a candidate and not elected in any set. In this case, the deposit is
             * unreserved, returned and origin is removed as a candidate.
             * - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
             * origin is removed as a runner-up.
             * - `origin` is a current member. In this case, the deposit is unreserved and origin is
             * removed as a member, consequently not being a candidate for the next round anymore.
             * Similar to [`remove_members`], if replacement runners exists, they are immediately used.
             * If the prime is renouncing, then no prime will exist until the next round.
             *
             * The dispatch origin of this call must be signed, and have one of the above roles.
             *
             * # <weight>
             * The type of renouncing must be provided as witness data.
             * # </weight>
             **/
            renounceCandidacy: AugmentedSubmittable<(renouncing: Renouncing | {
                Member: any;
            } | {
                RunnerUp: any;
            } | {
                Candidate: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Renouncing]>;
            /**
             * Submit oneself for candidacy. A fixed amount of deposit is recorded.
             *
             * All candidates are wiped at the end of the term. They either become a member/runner-up,
             * or leave the system while their deposit is slashed.
             *
             * The dispatch origin of this call must be signed.
             *
             * ### Warning
             *
             * Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
             * to get their deposit back. Losing the spot in an election will always lead to a slash.
             *
             * # <weight>
             * The number of current candidates must be provided as witness data.
             * # </weight>
             **/
            submitCandidacy: AugmentedSubmittable<(candidateCount: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;
            /**
             * Vote for a set of candidates for the upcoming round of election. This can be called to
             * set the initial votes, or update already existing votes.
             *
             * Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
             * reserved. The deposit is based on the number of votes and can be updated over time.
             *
             * The `votes` should:
             * - not be empty.
             * - be less than the number of possible candidates. Note that all current members and
             * runners-up are also automatically candidates for the next round.
             *
             * If `value` is more than `who`'s total balance, then the maximum of the two is used.
             *
             * The dispatch origin of this call must be signed.
             *
             * ### Warning
             *
             * It is the responsibility of the caller to **NOT** place all of their balance into the
             * lock and keep some for further operations.
             *
             * # <weight>
             * We assume the maximum weight among all 3 cases: vote_equal, vote_more and vote_less.
             * # </weight>
             **/
            vote: AugmentedSubmittable<(votes: Vec<AccountId> | (AccountId | string | Uint8Array)[], value: Compact<BalanceOf> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Vec<AccountId>, Compact<BalanceOf>]>;
        };
        ethereum: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Transact an Ethereum transaction.
             **/
            transact: AugmentedSubmittable<(transaction: EthTransaction | {
                nonce?: any;
                gasPrice?: any;
                gasLimit?: any;
                action?: any;
                value?: any;
                input?: any;
                v?: any;
                r?: any;
                s?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [EthTransaction]>;
        };
        ethereumBacking: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Lock some balances into the module account
             * which very similar to lock some assets into the contract on ethereum side
             *
             * This might kill the account just like `balances::transfer`
             **/
            lock: AugmentedSubmittable<(ringToLock: Compact<RingBalance> | AnyNumber | Uint8Array, ktonToLock: Compact<KtonBalance> | AnyNumber | Uint8Array, ethereumAccount: EthereumAddress | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<RingBalance>, Compact<KtonBalance>, EthereumAddress]>;
            /**
             * Redeem balances
             *
             * # <weight>
             * - `O(1)`
             * # </weight>
             **/
            redeem: AugmentedSubmittable<(act: RedeemFor | 'Token' | 'Deposit' | number | Uint8Array, proof: EthereumReceiptProofThing) => SubmittableExtrinsic<ApiType>, [RedeemFor, EthereumReceiptProofThing]>;
            /**
             * Set a new deposit redeem address.
             *
             * The dispatch origin of this call must be _Root_.
             *
             * - `new`: The new deposit redeem address.
             *
             * # <weight>
             * - `O(1)`.
             * # </weight>
             **/
            setDepositRedeemAddress: AugmentedSubmittable<(updated: EthereumAddress | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [EthereumAddress]>;
            setRedeemStatus: AugmentedSubmittable<(status: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [bool]>;
            /**
             * Set a new ring redeem address.
             *
             * The dispatch origin of this call must be _Root_.
             *
             * - `new`: The new ring redeem address.
             *
             * # <weight>
             * - `O(1)`.
             * # </weight>
             **/
            setTokenRedeemAddress: AugmentedSubmittable<(updated: EthereumAddress | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [EthereumAddress]>;
            syncAuthoritiesChange: AugmentedSubmittable<(proof: EthereumReceiptProofThing) => SubmittableExtrinsic<ApiType>, [EthereumReceiptProofThing]>;
        };
        ethereumRelay: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            affirm: AugmentedSubmittable<(ethereumRelayHeaderParcel: EthereumRelayHeaderParcel | {
                header?: any;
                parentMmrRoot?: any;
            } | string | Uint8Array, optionalEthereumRelayProofs: Option<EthereumRelayProofs> | null | object | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [EthereumRelayHeaderParcel, Option<EthereumRelayProofs>]>;
            /**
             * Check and verify the receipt
             *
             * `check_receipt` will verify the validation of the ethereum receipt proof from ethereum.
             * Ethereum receipt proof are constructed with 3 parts.
             *
             * The first part `ethereum_proof_record` is the Ethereum receipt and its merkle member proof regarding
             * to the receipt root in related Ethereum block header.
             *
             * The second part `ethereum_header` is the Ethereum block header which included/generated this
             * receipt, we need to provide this as part of proof, because in Darwinia Relay, we only have
             * last confirmed block's MMR root, don't have previous blocks, so we need to include this to
             * provide the `receipt_root` inside it, we will need to verify validation by checking header hash.
             *
             * The third part `mmr_proof` is the mmr proof generate according to
             * `(member_index=[ethereum_header.number], last_index=last_confirmed_block_header.number)`
             * it can prove that the `ethereum_header` is the chain which is committed by last confirmed block's `mmr_root`
             *
             * The dispatch origin for this call must be `Signed` by the transactor.
             *
             * # <weight>
             * - `O(1)`.
             * - Limited Storage reads
             * - Up to one event
             *
             * Related functions:
             *
             * - `set_receipt_verify_fee` can be used to set the verify fee for each receipt check.
             * # </weight>
             **/
            checkReceipt: AugmentedSubmittable<(ethereumProofRecord: EthereumReceiptProof | {
                index?: any;
                proof?: any;
                headerHash?: any;
            } | string | Uint8Array, ethereumHeader: EthereumHeader | {
                parentHash?: any;
                timestamp?: any;
                number?: any;
                author?: any;
                transactionsRoot?: any;
                unclesHash?: any;
                extraData?: any;
                stateRoot?: any;
                receiptsRoot?: any;
                logBloom?: any;
                gasUsed?: any;
                gasLimit?: any;
                difficulty?: any;
                seal?: any;
                baseFeePerGas?: any;
                blockHash?: any;
            } | string | Uint8Array, mmrProof: MMRProof | {
                memberLeafIndex?: any;
                lastLeafIndex?: any;
                proof?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [EthereumReceiptProof, EthereumHeader, MMRProof]>;
            /**
             * Caution: the genesis parcel will be removed too
             **/
            cleanConfirmedParcels: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            completeRelayProofs: AugmentedSubmittable<(affirmationId: RelayAffirmationId | {
                relayHeaderId?: any;
                round?: any;
                index?: any;
            } | string | Uint8Array, ethereumRelayProofs: Vec<EthereumRelayProofs> | (EthereumRelayProofs | {
                ethashProof?: any;
                mmrProof?: any;
            } | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [RelayAffirmationId, Vec<EthereumRelayProofs>]>;
            disputeAndAffirm: AugmentedSubmittable<(ethereumRelayHeaderParcel: EthereumRelayHeaderParcel | {
                header?: any;
                parentMmrRoot?: any;
            } | string | Uint8Array, optionalEthereumRelayProofs: Option<EthereumRelayProofs> | null | object | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [EthereumRelayHeaderParcel, Option<EthereumRelayProofs>]>;
            extendAffirmation: AugmentedSubmittable<(extendedEthereumRelayAffirmationId: RelayAffirmationId | {
                relayHeaderId?: any;
                round?: any;
                index?: any;
            } | string | Uint8Array, gameSamplePoints: Vec<EthereumRelayHeaderParcel> | (EthereumRelayHeaderParcel | {
                header?: any;
                parentMmrRoot?: any;
            } | string | Uint8Array)[], optionalEthereumRelayProofs: Option<Vec<EthereumRelayProofs>> | null | object | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [RelayAffirmationId, Vec<EthereumRelayHeaderParcel>, Option<Vec<EthereumRelayProofs>>]>;
            /**
             * Remove the specific malicous confirmed parcel
             **/
            removeConfirmedParcelOf: AugmentedSubmittable<(confirmedBlockNumber: EthereumBlockNumber | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [EthereumBlockNumber]>;
            setConfirmedParcel: AugmentedSubmittable<(ethereumRelayHeaderParcel: EthereumRelayHeaderParcel | {
                header?: any;
                parentMmrRoot?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [EthereumRelayHeaderParcel]>;
            /**
             * Set verify receipt fee
             *
             * # <weight>
             * - `O(1)`.
             * - One storage write
             * # </weight>
             **/
            setReceiptVerifyFee: AugmentedSubmittable<(updated: Compact<RingBalance> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<RingBalance>]>;
            votePendingRelayHeaderParcel: AugmentedSubmittable<(ethereumBlockNumber: EthereumBlockNumber | AnyNumber | Uint8Array, aye: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [EthereumBlockNumber, bool]>;
        };
        ethereumRelayAuthorities: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Require add origin
             *
             * Add an authority from the candidates
             *
             * This call is disallowed during the authorities change
             **/
            addAuthorities: AugmentedSubmittable<(accountIds: Vec<AccountId> | (AccountId | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<AccountId>]>;
            /**
             * This would never fail. No-op if can't find the request
             **/
            cancelRequest: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            forceNewTerm: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            killAuthorities: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            /**
             * Require reset origin
             *
             * Clear the candidates
             **/
            killCandidates: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            /**
             * Require remove origin
             *
             * This call is disallowed during the authorities change
             **/
            removeAuthorities: AugmentedSubmittable<(accountIds: Vec<AccountId> | (AccountId | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<AccountId>]>;
            /**
             * Renounce the authority for you
             *
             * This call is disallowed during the authorities change
             *
             * No-op if can't find the authority
             *
             * Will fail if you still in the term
             **/
            renounceAuthority: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            /**
             * Request to be an authority
             *
             * This will be failed if match one of these sections:
             * - already is a candidate
             * - already is an authority
             * - insufficient stake, required at least more than the last candidate's
             * if too there're many candidates in the candidates' queue
             **/
            requestAuthority: AugmentedSubmittable<(stake: RingBalance | AnyNumber | Uint8Array, signer: RelayAuthoritySigner | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [RingBalance, RelayAuthoritySigner]>;
            /**
             * Require authority origin
             *
             * This call is only allowed during the authorities change
             *
             * No-op if already submit
             *
             * Verify
             * - the relay requirement is valid
             * - the signature is signed by the submitter
             **/
            submitSignedAuthorities: AugmentedSubmittable<(signature: RelayAuthoritySignature | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [RelayAuthoritySignature]>;
            /**
             * Require authority origin
             *
             * This call is disallowed during the authorities change
             *
             * No-op if already submit
             *
             * Verify
             * - the relay requirement is valid
             * - the signature is signed by the submitter
             **/
            submitSignedMmrRoot: AugmentedSubmittable<(blockNumber: BlockNumber | AnyNumber | Uint8Array, signature: RelayAuthoritySignature | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [BlockNumber, RelayAuthoritySignature]>;
        };
        evm: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
             **/
            call: AugmentedSubmittable<(source: H160 | string | Uint8Array, target: H160 | string | Uint8Array, input: Bytes | string | Uint8Array, value: U256 | AnyNumber | Uint8Array, gasLimit: u64 | AnyNumber | Uint8Array, gasPrice: U256 | AnyNumber | Uint8Array, nonce: Option<U256> | null | object | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H160, H160, Bytes, U256, u64, U256, Option<U256>]>;
            /**
             * Issue an EVM create operation. This is similar to a contract creation transaction in
             * Ethereum.
             **/
            create: AugmentedSubmittable<(source: H160 | string | Uint8Array, init: Bytes | string | Uint8Array, value: U256 | AnyNumber | Uint8Array, gasLimit: u64 | AnyNumber | Uint8Array, gasPrice: U256 | AnyNumber | Uint8Array, nonce: Option<U256> | null | object | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H160, Bytes, U256, u64, U256, Option<U256>]>;
            /**
             * Issue an EVM create2 operation.
             **/
            create2: AugmentedSubmittable<(source: H160 | string | Uint8Array, init: Bytes | string | Uint8Array, salt: H256 | string | Uint8Array, value: U256 | AnyNumber | Uint8Array, gasLimit: u64 | AnyNumber | Uint8Array, gasPrice: U256 | AnyNumber | Uint8Array, nonce: Option<U256> | null | object | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H160, Bytes, H256, U256, u64, U256, Option<U256>]>;
        };
        grandpa: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Note that the current authority set of the GRANDPA finality gadget has
             * stalled. This will trigger a forced authority set change at the beginning
             * of the next session, to be enacted `delay` blocks after that. The delay
             * should be high enough to safely assume that the block signalling the
             * forced change will not be re-orged (e.g. 1000 blocks). The GRANDPA voters
             * will start the new authority set using the given finalized block as base.
             * Only callable by root.
             **/
            noteStalled: AugmentedSubmittable<(delay: BlockNumber | AnyNumber | Uint8Array, bestFinalizedBlockNumber: BlockNumber | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [BlockNumber, BlockNumber]>;
            /**
             * Report voter equivocation/misbehavior. This method will verify the
             * equivocation proof and validate the given key ownership proof
             * against the extracted offender. If both are valid, the offence
             * will be reported.
             **/
            reportEquivocation: AugmentedSubmittable<(equivocationProof: GrandpaEquivocationProof | {
                setId?: any;
                equivocation?: any;
            } | string | Uint8Array, keyOwnerProof: KeyOwnerProof | {
                session?: any;
                trieNodes?: any;
                validatorCount?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [GrandpaEquivocationProof, KeyOwnerProof]>;
            /**
             * Report voter equivocation/misbehavior. This method will verify the
             * equivocation proof and validate the given key ownership proof
             * against the extracted offender. If both are valid, the offence
             * will be reported.
             *
             * This extrinsic must be called unsigned and it is expected that only
             * block authors will call it (validated in `ValidateUnsigned`), as such
             * if the block author is defined it will be defined as the equivocation
             * reporter.
             **/
            reportEquivocationUnsigned: AugmentedSubmittable<(equivocationProof: GrandpaEquivocationProof | {
                setId?: any;
                equivocation?: any;
            } | string | Uint8Array, keyOwnerProof: KeyOwnerProof | {
                session?: any;
                trieNodes?: any;
                validatorCount?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [GrandpaEquivocationProof, KeyOwnerProof]>;
        };
        imOnline: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * # <weight>
             * - Complexity: `O(K + E)` where K is length of `Keys` (heartbeat.validators_len)
             * and E is length of `heartbeat.network_state.external_address`
             * - `O(K)`: decoding of length `K`
             * - `O(E)`: decoding/encoding of length `E`
             * - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,
             * `ReceivedHeartbeats`
             * - DbWrites: `ReceivedHeartbeats`
             * # </weight>
             **/
            heartbeat: AugmentedSubmittable<(heartbeat: Heartbeat | {
                blockNumber?: any;
                networkState?: any;
                sessionIndex?: any;
                authorityIndex?: any;
                validatorsLen?: any;
            } | string | Uint8Array, signature: Signature | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Heartbeat, Signature]>;
        };
        kton: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Exactly as `transfer`, except the origin must be root and the source account may be
             * specified.
             * # <weight>
             * - Same as transfer, but additional read and write because the source account is
             * not assumed to be in the overlay.
             * # </weight>
             **/
            forceTransfer: AugmentedSubmittable<(source: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, dest: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, value: Compact<Balance> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [LookupSource, LookupSource, Compact<Balance>]>;
            /**
             * Set the balances of a given account.
             *
             * This will alter `FreeBalance` and `ReservedBalance` in storage. it will
             * also decrease the total issuance of the system (`TotalIssuance`).
             * If the new free or reserved balance is below the existential deposit,
             * it will reset the account nonce (`frame_system::AccountNonce`).
             *
             * The dispatch origin for this call is `root`.
             *
             * # <weight>
             * - Independent of the arguments.
             * - Contains a limited number of reads and writes.
             * # </weight>
             **/
            setBalance: AugmentedSubmittable<(who: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, newFree: Compact<Balance> | AnyNumber | Uint8Array, newReserved: Compact<Balance> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [LookupSource, Compact<Balance>, Compact<Balance>]>;
            /**
             * Transfer some liquid free balance to another account.
             *
             * `transfer` will set the `FreeBalance` of the sender and receiver.
             * It will decrease the total issuance of the system by the `TransferFee`.
             * If the sender's account is below the existential deposit as a result
             * of the transfer, the account will be reaped.
             *
             * The dispatch origin for this call must be `Signed` by the transactor.
             *
             * # <weight>
             * - Dependent on arguments but not critical, given proper implementations for
             * input config types. See related functions below.
             * - It contains a limited number of reads and writes internally and no complex computation.
             *
             * Related functions:
             *
             * - `ensure_can_withdraw` is always called internally but has a bounded complexity.
             * - Transferring balances to accounts that did not exist before will cause
             * `T::OnNewAccount::on_new_account` to be called.
             * - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.
             * - `transfer_keep_alive` works the same way as `transfer`, but has an additional
             * check that the transfer will not kill the origin account.
             *
             * # </weight>
             **/
            transfer: AugmentedSubmittable<(dest: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, value: Compact<Balance> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [LookupSource, Compact<Balance>]>;
            /**
             * Same as the [`transfer`] call, but with a check that the transfer will not kill the
             * origin account.
             *
             * 99% of the time you want [`transfer`] instead.
             *
             * [`transfer`]: struct.Module.html#method.transfer
             **/
            transferKeepAlive: AugmentedSubmittable<(dest: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, value: Compact<Balance> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [LookupSource, Compact<Balance>]>;
        };
        proxy: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Register a proxy account for the sender that is able to make calls on its behalf.
             *
             * The dispatch origin for this call must be _Signed_.
             *
             * Parameters:
             * - `proxy`: The account that the `caller` would like to make a proxy.
             * - `proxy_type`: The permissions allowed for this proxy account.
             * - `delay`: The announcement period required of the initial proxy. Will generally be
             * zero.
             *
             * # <weight>
             * Weight is a function of the number of proxies the user has (P).
             * # </weight>
             **/
            addProxy: AugmentedSubmittable<(delegate: AccountId | string | Uint8Array, proxyType: ProxyType | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | 'IdentityJudgement' | 'EthereumBridge' | number | Uint8Array, delay: BlockNumber | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId, ProxyType, BlockNumber]>;
            /**
             * Publish the hash of a proxy-call that will be made in the future.
             *
             * This must be called some number of blocks before the corresponding `proxy` is attempted
             * if the delay associated with the proxy relationship is greater than zero.
             *
             * No more than `MaxPending` announcements may be made at any one time.
             *
             * This will take a deposit of `AnnouncementDepositFactor` as well as
             * `AnnouncementDepositBase` if there are no other pending announcements.
             *
             * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
             *
             * Parameters:
             * - `real`: The account that the proxy will make a call on behalf of.
             * - `call_hash`: The hash of the call to be made by the `real` account.
             *
             * # <weight>
             * Weight is a function of:
             * - A: the number of announcements made.
             * - P: the number of proxies the user has.
             * # </weight>
             **/
            announce: AugmentedSubmittable<(real: AccountId | string | Uint8Array, callHash: CallHashOf | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId, CallHashOf]>;
            /**
             * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
             * initialize it with a proxy of `proxy_type` for `origin` sender.
             *
             * Requires a `Signed` origin.
             *
             * - `proxy_type`: The type of the proxy that the sender will be registered as over the
             * new account. This will almost always be the most permissive `ProxyType` possible to
             * allow for maximum flexibility.
             * - `index`: A disambiguation index, in case this is called multiple times in the same
             * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
             * want to use `0`.
             * - `delay`: The announcement period required of the initial proxy. Will generally be
             * zero.
             *
             * Fails with `Duplicate` if this has already been called in this transaction, from the
             * same sender, with the same parameters.
             *
             * Fails if there are insufficient funds to pay for deposit.
             *
             * # <weight>
             * Weight is a function of the number of proxies the user has (P).
             * # </weight>
             * TODO: Might be over counting 1 read
             **/
            anonymous: AugmentedSubmittable<(proxyType: ProxyType | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | 'IdentityJudgement' | 'EthereumBridge' | number | Uint8Array, delay: BlockNumber | AnyNumber | Uint8Array, index: u16 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [ProxyType, BlockNumber, u16]>;
            /**
             * Removes a previously spawned anonymous proxy.
             *
             * WARNING: **All access to this account will be lost.** Any funds held in it will be
             * inaccessible.
             *
             * Requires a `Signed` origin, and the sender account must have been created by a call to
             * `anonymous` with corresponding parameters.
             *
             * - `spawner`: The account that originally called `anonymous` to create this account.
             * - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.
             * - `proxy_type`: The proxy type originally passed to `anonymous`.
             * - `height`: The height of the chain when the call to `anonymous` was processed.
             * - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.
             *
             * Fails with `NoPermission` in case the caller is not a previously created anonymous
             * account whose `anonymous` call has corresponding parameters.
             *
             * # <weight>
             * Weight is a function of the number of proxies the user has (P).
             * # </weight>
             **/
            killAnonymous: AugmentedSubmittable<(spawner: AccountId | string | Uint8Array, proxyType: ProxyType | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | 'IdentityJudgement' | 'EthereumBridge' | number | Uint8Array, index: u16 | AnyNumber | Uint8Array, height: Compact<BlockNumber> | AnyNumber | Uint8Array, extIndex: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId, ProxyType, u16, Compact<BlockNumber>, Compact<u32>]>;
            /**
             * Dispatch the given `call` from an account that the sender is authorised for through
             * `add_proxy`.
             *
             * Removes any corresponding announcement(s).
             *
             * The dispatch origin for this call must be _Signed_.
             *
             * Parameters:
             * - `real`: The account that the proxy will make a call on behalf of.
             * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
             * - `call`: The call to be made by the `real` account.
             *
             * # <weight>
             * Weight is a function of the number of proxies the user has (P).
             * # </weight>
             **/
            proxy: AugmentedSubmittable<(real: AccountId | string | Uint8Array, forceProxyType: Option<ProxyType> | null | object | string | Uint8Array, call: Call | {
                callIndex?: any;
                args?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId, Option<ProxyType>, Call]>;
            /**
             * Dispatch the given `call` from an account that the sender is authorised for through
             * `add_proxy`.
             *
             * Removes any corresponding announcement(s).
             *
             * The dispatch origin for this call must be _Signed_.
             *
             * Parameters:
             * - `real`: The account that the proxy will make a call on behalf of.
             * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
             * - `call`: The call to be made by the `real` account.
             *
             * # <weight>
             * Weight is a function of:
             * - A: the number of announcements made.
             * - P: the number of proxies the user has.
             * # </weight>
             **/
            proxyAnnounced: AugmentedSubmittable<(delegate: AccountId | string | Uint8Array, real: AccountId | string | Uint8Array, forceProxyType: Option<ProxyType> | null | object | string | Uint8Array, call: Call | {
                callIndex?: any;
                args?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId, AccountId, Option<ProxyType>, Call]>;
            /**
             * Remove the given announcement of a delegate.
             *
             * May be called by a target (proxied) account to remove a call that one of their delegates
             * (`delegate`) has announced they want to execute. The deposit is returned.
             *
             * The dispatch origin for this call must be _Signed_.
             *
             * Parameters:
             * - `delegate`: The account that previously announced the call.
             * - `call_hash`: The hash of the call to be made.
             *
             * # <weight>
             * Weight is a function of:
             * - A: the number of announcements made.
             * - P: the number of proxies the user has.
             * # </weight>
             **/
            rejectAnnouncement: AugmentedSubmittable<(delegate: AccountId | string | Uint8Array, callHash: CallHashOf | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId, CallHashOf]>;
            /**
             * Remove a given announcement.
             *
             * May be called by a proxy account to remove a call they previously announced and return
             * the deposit.
             *
             * The dispatch origin for this call must be _Signed_.
             *
             * Parameters:
             * - `real`: The account that the proxy will make a call on behalf of.
             * - `call_hash`: The hash of the call to be made by the `real` account.
             *
             * # <weight>
             * Weight is a function of:
             * - A: the number of announcements made.
             * - P: the number of proxies the user has.
             * # </weight>
             **/
            removeAnnouncement: AugmentedSubmittable<(real: AccountId | string | Uint8Array, callHash: CallHashOf | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId, CallHashOf]>;
            /**
             * Unregister all proxy accounts for the sender.
             *
             * The dispatch origin for this call must be _Signed_.
             *
             * WARNING: This may be called on accounts created by `anonymous`, however if done, then
             * the unreserved fees will be inaccessible. **All access to this account will be lost.**
             *
             * # <weight>
             * Weight is a function of the number of proxies the user has (P).
             * # </weight>
             **/
            removeProxies: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            /**
             * Unregister a proxy account for the sender.
             *
             * The dispatch origin for this call must be _Signed_.
             *
             * Parameters:
             * - `proxy`: The account that the `caller` would like to remove as a proxy.
             * - `proxy_type`: The permissions currently enabled for the removed proxy account.
             *
             * # <weight>
             * Weight is a function of the number of proxies the user has (P).
             * # </weight>
             **/
            removeProxy: AugmentedSubmittable<(delegate: AccountId | string | Uint8Array, proxyType: ProxyType | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | 'IdentityJudgement' | 'EthereumBridge' | number | Uint8Array, delay: BlockNumber | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId, ProxyType, BlockNumber]>;
        };
        scheduler: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Cancel an anonymously scheduled task.
             *
             * # <weight>
             * - S = Number of already scheduled calls
             * - Base Weight: 22.15 + 2.869 * S µs
             * - DB Weight:
             * - Read: Agenda
             * - Write: Agenda, Lookup
             * - Will use base weight of 100 which should be good for up to 30 scheduled calls
             * # </weight>
             **/
            cancel: AugmentedSubmittable<(when: BlockNumber | AnyNumber | Uint8Array, index: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [BlockNumber, u32]>;
            /**
             * Cancel a named scheduled task.
             *
             * # <weight>
             * - S = Number of already scheduled calls
             * - Base Weight: 24.91 + 2.907 * S µs
             * - DB Weight:
             * - Read: Agenda, Lookup
             * - Write: Agenda, Lookup
             * - Will use base weight of 100 which should be good for up to 30 scheduled calls
             * # </weight>
             **/
            cancelNamed: AugmentedSubmittable<(id: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;
            /**
             * Anonymously schedule a task.
             *
             * # <weight>
             * - S = Number of already scheduled calls
             * - Base Weight: 22.29 + .126 * S µs
             * - DB Weight:
             * - Read: Agenda
             * - Write: Agenda
             * - Will use base weight of 25 which should be good for up to 30 scheduled calls
             * # </weight>
             **/
            schedule: AugmentedSubmittable<(when: BlockNumber | AnyNumber | Uint8Array, maybePeriodic: Option<Period> | null | object | string | Uint8Array, priority: Priority | AnyNumber | Uint8Array, call: Call | {
                callIndex?: any;
                args?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [BlockNumber, Option<Period>, Priority, Call]>;
            /**
             * Anonymously schedule a task after a delay.
             *
             * # <weight>
             * Same as [`schedule`].
             * # </weight>
             **/
            scheduleAfter: AugmentedSubmittable<(after: BlockNumber | AnyNumber | Uint8Array, maybePeriodic: Option<Period> | null | object | string | Uint8Array, priority: Priority | AnyNumber | Uint8Array, call: Call | {
                callIndex?: any;
                args?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [BlockNumber, Option<Period>, Priority, Call]>;
            /**
             * Schedule a named task.
             *
             * # <weight>
             * - S = Number of already scheduled calls
             * - Base Weight: 29.6 + .159 * S µs
             * - DB Weight:
             * - Read: Agenda, Lookup
             * - Write: Agenda, Lookup
             * - Will use base weight of 35 which should be good for more than 30 scheduled calls
             * # </weight>
             **/
            scheduleNamed: AugmentedSubmittable<(id: Bytes | string | Uint8Array, when: BlockNumber | AnyNumber | Uint8Array, maybePeriodic: Option<Period> | null | object | string | Uint8Array, priority: Priority | AnyNumber | Uint8Array, call: Call | {
                callIndex?: any;
                args?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes, BlockNumber, Option<Period>, Priority, Call]>;
            /**
             * Schedule a named task after a delay.
             *
             * # <weight>
             * Same as [`schedule_named`].
             * # </weight>
             **/
            scheduleNamedAfter: AugmentedSubmittable<(id: Bytes | string | Uint8Array, after: BlockNumber | AnyNumber | Uint8Array, maybePeriodic: Option<Period> | null | object | string | Uint8Array, priority: Priority | AnyNumber | Uint8Array, call: Call | {
                callIndex?: any;
                args?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes, BlockNumber, Option<Period>, Priority, Call]>;
        };
        session: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Removes any session key(s) of the function caller.
             * This doesn't take effect until the next session.
             *
             * The dispatch origin of this function must be signed.
             *
             * # <weight>
             * - Complexity: `O(1)` in number of key types.
             * Actual cost depends on the number of length of `T::Keys::key_ids()` which is fixed.
             * - DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`
             * - DbWrites: `NextKeys`, `origin account`
             * - DbWrites per key id: `KeyOwnder`
             * # </weight>
             **/
            purgeKeys: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            /**
             * Sets the session key(s) of the function caller to `keys`.
             * Allows an account to set its session key prior to becoming a validator.
             * This doesn't take effect until the next session.
             *
             * The dispatch origin of this function must be signed.
             *
             * # <weight>
             * - Complexity: `O(1)`
             * Actual cost depends on the number of length of `T::Keys::key_ids()` which is fixed.
             * - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`
             * - DbWrites: `origin account`, `NextKeys`
             * - DbReads per key id: `KeyOwner`
             * - DbWrites per key id: `KeyOwner`
             * # </weight>
             **/
            setKeys: AugmentedSubmittable<(keys: Keys, proof: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Keys, Bytes]>;
        };
        staking: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Take the origin account as a stash and lock up `value` of its balance. `controller` will
             * be the account that controls it.
             *
             * `value` must be more than the `minimum_balance` specified by `T::Currency`.
             *
             * The dispatch origin for this call must be _Signed_ by the stash account.
             *
             * # <weight>
             * - Independent of the arguments. Moderate complexity.
             * - O(1).
             * - Three extra DB entries.
             *
             * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
             * unless the `origin` falls below _existential deposit_ and gets removed as dust.
             * ------------------
             * Weight: O(1)
             * DB Weight:
             * - Read: Bonded, Ledger, [Origin Account], Current Era, History Depth, Locks
             * - Write: Bonded, Payee, [Origin Account], Locks, Ledger
             * # </weight>
             **/
            bond: AugmentedSubmittable<(controller: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, value: StakingBalanceT | {
                RingBalance: any;
            } | {
                KtonBalance: any;
            } | string | Uint8Array, payee: RewardDestination | {
                Staked: any;
            } | {
                Stash: any;
            } | {
                Controller: any;
            } | {
                Account: any;
            } | string | Uint8Array, promiseMonth: u8 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [LookupSource, StakingBalanceT, RewardDestination, u8]>;
            /**
             * Add some extra amount that have appeared in the stash `free_balance` into the balance up
             * for staking.
             *
             * Use this if there are additional funds in your stash account that you wish to bond.
             * Unlike [`bond`] or [`unbond`] this function does not impose any limitation on the amount
             * that can be added.
             *
             * The dispatch origin for this call must be _Signed_ by the stash, not the controller and
             * it can be only called when [`EraElectionStatus`] is `Closed`.
             *
             * Emits `Bonded`.
             *
             * # <weight>
             * - Independent of the arguments. Insignificant complexity.
             * - O(1).
             * - One DB entry.
             * ------------
             * DB Weight:
             * - Read: Era Election Status, Bonded, Ledger, [Origin Account], Locks
             * - Write: [Origin Account], Locks, Ledger
             * # </weight>
             **/
            bondExtra: AugmentedSubmittable<(maxAdditional: StakingBalanceT | {
                RingBalance: any;
            } | {
                KtonBalance: any;
            } | string | Uint8Array, promiseMonth: u8 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [StakingBalanceT, u8]>;
            /**
             * Cancel enactment of a deferred slash.
             *
             * Can be called by the `T::SlashCancelOrigin`.
             *
             * Parameters: era and indices of the slashes for that era to kill.
             *
             * # <weight>
             * Complexity: O(U + S)
             * with U unapplied slashes weighted with U=1000
             * and S is the number of slash indices to be canceled.
             * - Read: Unapplied Slashes
             * - Write: Unapplied Slashes
             * # </weight>
             **/
            cancelDeferredSlash: AugmentedSubmittable<(era: EraIndex | AnyNumber | Uint8Array, slashIndices: Vec<u32> | (u32 | AnyNumber | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [EraIndex, Vec<u32>]>;
            /**
             * Declare no desire to either validate or nominate.
             *
             * Effects will be felt at the beginning of the next era.
             *
             * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
             * And, it can be only called when [`EraElectionStatus`] is `Closed`.
             *
             * # <weight>
             * - Independent of the arguments. Insignificant complexity.
             * - Contains one read.
             * - Writes are limited to the `origin` account key.
             * --------
             * Weight: O(1)
             * DB Weight:
             * - Read: EraElectionStatus, Ledger
             * - Write: Validators, Nominators
             * # </weight>
             **/
            chill: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            /**
             * Stash accounts can get their ring back after the depositing time exceeded,
             * and the ring getting back is still in staking status.
             *
             * # <weight>
             * - Independent of the arguments. Insignificant complexity.
             * - One storage read.
             * - One storage write.
             * - Writes are limited to the `origin` account key.
             * ----------
             * DB Weight:
             * - Read: Ledger, [Origin Account]
             * - Write: [Origin Account], Ledger
             * # </weight>
             **/
            claimMatureDeposits: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            /**
             * Deposit some extra amount ring, and return kton to the controller.
             *
             * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
             *
             * Is a no-op if value to be deposited is zero.
             *
             * # <weight>
             * - Independent of the arguments. Insignificant complexity.
             * - O(1).
             * - One DB entry.
             * ------------
             * DB Weight:
             * - Read: Era Election Status, Bonded, Ledger, [Origin Account]
             * - Write: [Origin Account], Ledger
             * # </weight>
             **/
            depositExtra: AugmentedSubmittable<(value: RingBalance | AnyNumber | Uint8Array, promiseMonth: u8 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [RingBalance, u8]>;
            /**
             * Force there to be a new era at the end of the next session. After this, it will be
             * reset to normal (non-forced) behaviour.
             *
             * The dispatch origin must be Root.
             *
             * # <weight>
             * - No arguments.
             * - Weight: O(1)
             * - Write ForceEra
             * # </weight>
             **/
            forceNewEra: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            /**
             * Force there to be a new era at the end of sessions indefinitely.
             *
             * The dispatch origin must be Root.
             *
             * # <weight>
             * - Weight: O(1)
             * - Write: ForceEra
             * # </weight>
             **/
            forceNewEraAlways: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            /**
             * Force there to be no new eras indefinitely.
             *
             * The dispatch origin must be Root.
             *
             * # <weight>
             * - No arguments.
             * - Weight: O(1)
             * - Write: ForceEra
             * # </weight>
             **/
            forceNoEras: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            /**
             * Force a current staker to become completely unstaked, immediately.
             *
             * The dispatch origin must be Root.
             *
             * # <weight>
             * O(S) where S is the number of slashing spans to be removed
             * Reads: Bonded, Slashing Spans, Account, Locks
             * Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Account, Locks
             * Writes Each: SpanSlash * S
             * # </weight>
             **/
            forceUnstake: AugmentedSubmittable<(stash: AccountId | string | Uint8Array, numSlashingSpans: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId, u32]>;
            /**
             * Increments the ideal number of validators.
             *
             * The dispatch origin must be Root.
             *
             * # <weight>
             * Same as [`set_validator_count`].
             * # </weight>
             **/
            increaseValidatorCount: AugmentedSubmittable<(additional: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;
            /**
             * Remove the given nominations from the calling validator.
             *
             * Effects will be felt at the beginning of the next era.
             *
             * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
             * And, it can be only called when [`EraElectionStatus`] is `Closed`. The controller
             * account should represent a validator.
             *
             * - `who`: A list of nominator stash accounts who are nominating this validator which
             * should no longer be nominating this validator.
             *
             * Note: Making this call only makes sense if you first set the validator preferences to
             * block any further nominations.
             **/
            kick: AugmentedSubmittable<(who: Vec<LookupSource> | (LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<LookupSource>]>;
            /**
             * Declare the desire to nominate `targets` for the origin controller.
             *
             * Effects will be felt at the beginning of the next era. This can only be called when
             * [`EraElectionStatus`] is `Closed`.
             *
             * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
             * And, it can be only called when [`EraElectionStatus`] is `Closed`.
             *
             * # <weight>
             * - The transaction's complexity is proportional to the size of `targets` (N)
             * which is capped at CompactAssignments::LIMIT (MAX_NOMINATIONS).
             * - Both the reads and writes follow a similar pattern.
             * ---------
             * Weight: O(N)
             * where N is the number of targets
             * DB Weight:
             * - Reads: Era Election Status, Ledger, Current Era
             * - Writes: Validators, Nominators
             * # </weight>
             **/
            nominate: AugmentedSubmittable<(targets: Vec<LookupSource> | (LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<LookupSource>]>;
            /**
             * Pay out all the stakers behind a single validator for a single era.
             *
             * - `validator_stash` is the stash account of the validator. Their nominators, up to
             * `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.
             * - `era` may be any era between `[current_era - history_depth; current_era]`.
             *
             * The origin of this call must be _Signed_. Any account can call this function, even if
             * it is not one of the stakers.
             *
             * This can only be called when [`EraElectionStatus`] is `Closed`.
             *
             * # <weight>
             * - Time complexity: at most O(MaxNominatorRewardedPerValidator).
             * - Contains a limited number of reads and writes.
             * -----------
             * N is the Number of payouts for the validator (including the validator)
             * Weight:
             * - Reward Destination Staked: O(N)
             * - Reward Destination Controller (Creating): O(N)
             * DB Weight:
             * - Read: EraElectionStatus, CurrentEra, HistoryDepth, ErasValidatorReward,
             * ErasStakersClipped, ErasRewardPoints, ErasValidatorPrefs (8 items)
             * - Read Each: Bonded, Ledger, Payee, Locks, System Account (5 items)
             * - Write Each: System Account, Locks, Ledger (3 items)
             *
             * NOTE: weights are assuming that payouts are made to alive stash account (Staked).
             * Paying even a dead controller is cheaper weight-wise. We don't do any refunds here.
             * # </weight>
             **/
            payoutStakers: AugmentedSubmittable<(validatorStash: AccountId | string | Uint8Array, era: EraIndex | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId, EraIndex]>;
            /**
             * Remove all data structure concerning a staker/stash once its balance is at the minimum.
             * This is essentially equivalent to `withdraw_unbonded` except it can be called by anyone
             * and the target `stash` must have no funds left beyond the ED.
             *
             * This can be called from any origin.
             *
             * - `stash`: The stash account to reap. Its balance must be zero.
             *
             * # <weight>
             * Complexity: O(S) where S is the number of slashing spans on the account.
             * DB Weight:
             * - Reads: Stash Account, Bonded, Slashing Spans, Locks
             * - Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Stash Account, Locks
             * - Writes Each: SpanSlash * S
             * # </weight>
             **/
            reapStash: AugmentedSubmittable<(stash: AccountId | string | Uint8Array, numSlashingSpans: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId, u32]>;
            /**
             * Rebond a portion of the stash scheduled to be unlocked.
             *
             * The dispatch origin must be signed by the controller, and it can be only called when
             * [`EraElectionStatus`] is `Closed`.
             *
             * # <weight>
             * - Time complexity: O(L), where L is unlocking chunks
             * - Bounded by `MAX_UNLOCKING_CHUNKS`.
             * - Storage changes: Can't increase storage, only decrease it.
             * ---------------
             * - DB Weight:
             * - Reads: EraElectionStatus, Ledger, Locks, [Origin Account]
             * - Writes: [Origin Account], Locks, Ledger
             * # </weight>
             **/
            rebond: AugmentedSubmittable<(planToRebondRing: Compact<RingBalance> | AnyNumber | Uint8Array, planToRebondKton: Compact<KtonBalance> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<RingBalance>, Compact<KtonBalance>]>;
            /**
             * Scale up the ideal number of validators by a factor.
             *
             * The dispatch origin must be Root.
             *
             * # <weight>
             * Same as [`set_validator_count`].
             * # </weight>
             **/
            scaleValidatorCount: AugmentedSubmittable<(factor: Percent | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Percent]>;
            /**
             * (Re-)set the controller of a stash.
             *
             * Effects will be felt at the beginning of the next era.
             *
             * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
             *
             * # <weight>
             * - Independent of the arguments. Insignificant complexity.
             * - Contains a limited number of reads.
             * - Writes are limited to the `origin` account key.
             * ----------
             * Weight: O(1)
             * DB Weight:
             * - Read: Bonded, Ledger New Controller, Ledger Old Controller
             * - Write: Bonded, Ledger New Controller, Ledger Old Controller
             * # </weight>
             **/
            setController: AugmentedSubmittable<(controller: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [LookupSource]>;
            /**
             * Set `HistoryDepth` value. This function will delete any history information
             * when `HistoryDepth` is reduced.
             *
             * Parameters:
             * - `new_history_depth`: The new history depth you would like to set.
             * - `era_items_deleted`: The number of items that will be deleted by this dispatch.
             * This should report all the storage items that will be deleted by clearing old
             * era history. Needed to report an accurate weight for the dispatch. Trusted by
             * `Root` to report an accurate number.
             *
             * Origin must be root.
             *
             * # <weight>
             * - E: Number of history depths removed, i.e. 10 -> 7 = 3
             * - Weight: O(E)
             * - DB Weight:
             * - Reads: Current Era, History Depth
             * - Writes: History Depth
             * - Clear Prefix Each: Era Stakers, EraStakersClipped, ErasValidatorPrefs
             * - Writes Each: ErasValidatorReward, ErasRewardPoints, ErasTotalStake, ErasStartSessionIndex
             * # </weight>
             **/
            setHistoryDepth: AugmentedSubmittable<(newHistoryDepth: Compact<EraIndex> | AnyNumber | Uint8Array, eraItemsDeleted: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<EraIndex>, Compact<u32>]>;
            /**
             * Set the validators who cannot be slashed (if any).
             *
             * The dispatch origin must be Root.
             *
             * # <weight>
             * - O(V)
             * - Write: Invulnerables
             * # </weight>
             **/
            setInvulnerables: AugmentedSubmittable<(invulnerables: Vec<AccountId> | (AccountId | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<AccountId>]>;
            /**
             * (Re-)set the payment target for a controller.
             *
             * Effects will be felt at the beginning of the next era.
             *
             * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
             *
             * # <weight>
             * - Independent of the arguments. Insignificant complexity.
             * - Contains a limited number of reads.
             * - Writes are limited to the `origin` account key.
             * ---------
             * - Weight: O(1)
             * - DB Weight:
             * - Read: Ledger
             * - Write: Payee
             * # </weight>
             **/
            setPayee: AugmentedSubmittable<(payee: RewardDestination | {
                Staked: any;
            } | {
                Stash: any;
            } | {
                Controller: any;
            } | {
                Account: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [RewardDestination]>;
            /**
             * Sets the ideal number of validators.
             *
             * The dispatch origin must be Root.
             *
             * # <weight>
             * Weight: O(1)
             * Write: Validator Count
             * # </weight>
             **/
            setValidatorCount: AugmentedSubmittable<(updated: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;
            /**
             * Submit an election result to the chain. If the solution:
             *
             * 1. is valid.
             * 2. has a better score than a potentially existing solution on chain.
             *
             * then, it will be _put_ on chain.
             *
             * A solution consists of two pieces of data:
             *
             * 1. `winners`: a flat vector of all the winners of the round.
             * 2. `assignments`: the compact version of an assignment vector that encodes the edge
             * weights.
             *
             * Both of which may be computed using _phragmen_, or any other algorithm.
             *
             * Additionally, the submitter must provide:
             *
             * - The `score` that they claim their solution has.
             *
             * Both validators and nominators will be represented by indices in the solution. The
             * indices should respect the corresponding types ([`ValidatorIndex`] and
             * [`NominatorIndex`]). Moreover, they should be valid when used to index into
             * [`SnapshotValidators`] and [`SnapshotNominators`]. Any invalid index will cause the
             * solution to be rejected. These two storage items are set during the election window and
             * may be used to determine the indices.
             *
             * A solution is valid if:
             *
             * 0. It is submitted when [`EraElectionStatus`] is `Open`.
             * 1. Its claimed score is equal to the score computed on-chain.
             * 2. Presents the correct number of winners.
             * 3. All indexes must be value according to the snapshot vectors. All edge values must
             * also be correct and should not overflow the granularity of the ratio type (i.e. 256
             * or billion).
             * 4. For each edge, all targets are actually nominated by the voter.
             * 5. Has correct self-votes.
             *
             * A solutions score is consisted of 3 parameters:
             *
             * 1. `min { support.total }` for each support of a winner. This value should be maximized.
             * 2. `sum { support.total }` for each support of a winner. This value should be minimized.
             * 3. `sum { support.total^2 }` for each support of a winner. This value should be
             * minimized (to ensure less variance)
             *
             * # <weight>
             * The transaction is assumed to be the longest path, a better solution.
             * - Initial solution is almost the same.
             * - Worse solution is retraced in pre-dispatch-checks which sets its own weight.
             * # </weight>
             **/
            submitElectionSolution: AugmentedSubmittable<(winners: Vec<ValidatorIndex> | (ValidatorIndex | AnyNumber | Uint8Array)[], compact: CompactAssignments | {
                votes1?: any;
                votes2?: any;
                votes3?: any;
                votes4?: any;
                votes5?: any;
                votes6?: any;
                votes7?: any;
                votes8?: any;
                votes9?: any;
                votes10?: any;
                votes11?: any;
                votes12?: any;
                votes13?: any;
                votes14?: any;
                votes15?: any;
                votes16?: any;
            } | string | Uint8Array, score: ElectionScore, era: EraIndex | AnyNumber | Uint8Array, size: ElectionSize | {
                validators?: any;
                nominators?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Vec<ValidatorIndex>, CompactAssignments, ElectionScore, EraIndex, ElectionSize]>;
            /**
             * Unsigned version of `submit_election_solution`.
             *
             * Note that this must pass the [`ValidateUnsigned`] check which only allows transactions
             * from the local node to be included. In other words, only the block author can include a
             * transaction in the block.
             *
             * # <weight>
             * See [`submit_election_solution`].
             * # </weight>
             **/
            submitElectionSolutionUnsigned: AugmentedSubmittable<(winners: Vec<ValidatorIndex> | (ValidatorIndex | AnyNumber | Uint8Array)[], compact: CompactAssignments | {
                votes1?: any;
                votes2?: any;
                votes3?: any;
                votes4?: any;
                votes5?: any;
                votes6?: any;
                votes7?: any;
                votes8?: any;
                votes9?: any;
                votes10?: any;
                votes11?: any;
                votes12?: any;
                votes13?: any;
                votes14?: any;
                votes15?: any;
                votes16?: any;
            } | string | Uint8Array, score: ElectionScore, era: EraIndex | AnyNumber | Uint8Array, size: ElectionSize | {
                validators?: any;
                nominators?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Vec<ValidatorIndex>, CompactAssignments, ElectionScore, EraIndex, ElectionSize]>;
            /**
             * Claim deposits while the depositing time has not been exceeded, the ring
             * will not be slashed, but the account is required to pay KTON as punish.
             *
             * Refer to https://talk.darwinia.network/topics/55
             *
             * Assume the `expire_time` is a unique ID for the deposit
             *
             * # <weight>
             * - Independent of the arguments. Insignificant complexity.
             * - One storage read.
             * - One storage write.
             * - Writes are limited to the `origin` account key.
             * ----------
             * DB Weight:
             * - Read: Ledger, Locks, [Origin Account]
             * - Write: [Origin Account], Locks, Ledger
             * # </weight>
             **/
            tryClaimDepositsWithPunish: AugmentedSubmittable<(expireTime: TsInMs | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [TsInMs]>;
            /**
             * Schedule a portion of the stash to be unlocked ready for transfer out after the bond
             * period ends. If this leaves an amount actively bonded less than
             * T::Currency::minimum_balance(), then it is increased to the full amount.
             *
             * Once the unlock period is done, the funds will be withdrew automatically and ready for transfer.
             *
             * No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)
             * can co-exists at the same time. In that case,  [`StakingLock::shrink`] need
             * to be called first to remove some of the chunks (if possible).
             *
             * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
             * And, it can be only called when [`EraElectionStatus`] is `Closed`.
             *
             * After all pledged Ring and Kton are unbonded, the bonded accounts, namely stash and
             * controller, will also be unbonded.  Once user want to bond again, the `bond` method
             * should be called. If there are still pledged Ring or Kton and user want to bond more
             * values, the `bond_extra` method should be called.
             *
             * # <weight>
             * - Independent of the arguments. Limited but potentially exploitable complexity.
             * - Contains a limited number of reads.
             * - Each call (requires the remainder of the bonded balance to be above `minimum_balance`)
             * will cause a new entry to be inserted into a vector (`StakingLock.unbondings`) kept in storage.
             * - One DB entry.
             * ----------
             * Weight: O(1)
             * DB Weight:
             * - Read: EraElectionStatus, Ledger, CurrentEra, Locks, BalanceOf Stash,
             * - Write: Locks, Ledger, BalanceOf Stash,
             * </weight>
             **/
            unbond: AugmentedSubmittable<(value: StakingBalanceT | {
                RingBalance: any;
            } | {
                KtonBalance: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [StakingBalanceT]>;
            /**
             * Declare the desire to validate for the origin controller.
             *
             * Effects will be felt at the beginning of the next era.
             *
             * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
             * And, it can be only called when [`EraElectionStatus`] is `Closed`.
             *
             * # <weight>
             * - Independent of the arguments. Insignificant complexity.
             * - Contains a limited number of reads.
             * - Writes are limited to the `origin` account key.
             * -----------
             * Weight: O(1)
             * DB Weight:
             * - Read: Era Election Status, Ledger
             * - Write: Nominators, Validators
             * # </weight>
             **/
            validate: AugmentedSubmittable<(prefs: ValidatorPrefs | {
                commission?: any;
                blocked?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [ValidatorPrefs]>;
        };
        sudo: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.
             *
             * The dispatch origin for this call must be _Signed_.
             *
             * # <weight>
             * - O(1).
             * - Limited storage reads.
             * - One DB change.
             * # </weight>
             **/
            setKey: AugmentedSubmittable<(updated: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [LookupSource]>;
            /**
             * Authenticates the sudo key and dispatches a function call with `Root` origin.
             *
             * The dispatch origin for this call must be _Signed_.
             *
             * # <weight>
             * - O(1).
             * - Limited storage reads.
             * - One DB write (event).
             * - Weight of derivative `call` execution + 10,000.
             * # </weight>
             **/
            sudo: AugmentedSubmittable<(call: Call | {
                callIndex?: any;
                args?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Call]>;
            /**
             * Authenticates the sudo key and dispatches a function call with `Signed` origin from
             * a given account.
             *
             * The dispatch origin for this call must be _Signed_.
             *
             * # <weight>
             * - O(1).
             * - Limited storage reads.
             * - One DB write (event).
             * - Weight of derivative `call` execution + 10,000.
             * # </weight>
             **/
            sudoAs: AugmentedSubmittable<(who: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, call: Call | {
                callIndex?: any;
                args?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [LookupSource, Call]>;
            /**
             * Authenticates the sudo key and dispatches a function call with `Root` origin.
             * This function does not check the weight of the call, and instead allows the
             * Sudo user to specify the weight of the call.
             *
             * The dispatch origin for this call must be _Signed_.
             *
             * # <weight>
             * - O(1).
             * - The weight of this call is defined by the caller.
             * # </weight>
             **/
            sudoUncheckedWeight: AugmentedSubmittable<(call: Call | {
                callIndex?: any;
                args?: any;
            } | string | Uint8Array, weight: Weight | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Call, Weight]>;
        };
        system: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * A dispatch that will fill the block weight up to the given ratio.
             **/
            fillBlock: AugmentedSubmittable<(ratio: Perbill | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Perbill]>;
            /**
             * Kill all storage items with a key that starts with the given prefix.
             *
             * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
             * the prefix we are removing to accurately calculate the weight of this function.
             *
             * # <weight>
             * - `O(P)` where `P` amount of keys with prefix `prefix`
             * - `P` storage deletions.
             * - Base Weight: 0.834 * P µs
             * - Writes: Number of subkeys + 1
             * # </weight>
             **/
            killPrefix: AugmentedSubmittable<(prefix: Key | string | Uint8Array, subkeys: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Key, u32]>;
            /**
             * Kill some items from storage.
             *
             * # <weight>
             * - `O(IK)` where `I` length of `keys` and `K` length of one key
             * - `I` storage deletions.
             * - Base Weight: .378 * i µs
             * - Writes: Number of items
             * # </weight>
             **/
            killStorage: AugmentedSubmittable<(keys: Vec<Key> | (Key | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<Key>]>;
            /**
             * Make some on-chain remark.
             *
             * # <weight>
             * - `O(1)`
             * - Base Weight: 0.665 µs, independent of remark length.
             * - No DB operations.
             * # </weight>
             **/
            remark: AugmentedSubmittable<(remark: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;
            /**
             * Set the new changes trie configuration.
             *
             * # <weight>
             * - `O(1)`
             * - 1 storage write or delete (codec `O(1)`).
             * - 1 call to `deposit_log`: Uses `append` API, so O(1)
             * - Base Weight: 7.218 µs
             * - DB Weight:
             * - Writes: Changes Trie, System Digest
             * # </weight>
             **/
            setChangesTrieConfig: AugmentedSubmittable<(changesTrieConfig: Option<ChangesTrieConfiguration> | null | object | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Option<ChangesTrieConfiguration>]>;
            /**
             * Set the new runtime code.
             *
             * # <weight>
             * - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`
             * - 1 storage write (codec `O(C)`).
             * - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is expensive).
             * - 1 event.
             * The weight of this function is dependent on the runtime, but generally this is very expensive.
             * We will treat this as a full block.
             * # </weight>
             **/
            setCode: AugmentedSubmittable<(code: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;
            /**
             * Set the new runtime code without doing any checks of the given `code`.
             *
             * # <weight>
             * - `O(C)` where `C` length of `code`
             * - 1 storage write (codec `O(C)`).
             * - 1 event.
             * The weight of this function is dependent on the runtime. We will treat this as a full block.
             * # </weight>
             **/
            setCodeWithoutChecks: AugmentedSubmittable<(code: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;
            /**
             * Set the number of pages in the WebAssembly environment's heap.
             *
             * # <weight>
             * - `O(1)`
             * - 1 storage write.
             * - Base Weight: 1.405 µs
             * - 1 write to HEAP_PAGES
             * # </weight>
             **/
            setHeapPages: AugmentedSubmittable<(pages: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;
            /**
             * Set some items of storage.
             *
             * # <weight>
             * - `O(I)` where `I` length of `items`
             * - `I` storage writes (`O(1)`).
             * - Base Weight: 0.568 * i µs
             * - Writes: Number of items
             * # </weight>
             **/
            setStorage: AugmentedSubmittable<(items: Vec<KeyValue> | (KeyValue)[]) => SubmittableExtrinsic<ApiType>, [Vec<KeyValue>]>;
        };
        technicalCommittee: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Close a vote that is either approved, disapproved or whose voting period has ended.
             *
             * May be called by any signed account in order to finish voting and close the proposal.
             *
             * If called before the end of the voting period it will only close the vote if it is
             * has enough votes to be approved or disapproved.
             *
             * If called after the end of the voting period abstentions are counted as rejections
             * unless there is a prime member set and the prime member cast an approval.
             *
             * If the close operation completes successfully with disapproval, the transaction fee will
             * be waived. Otherwise execution of the approved operation will be charged to the caller.
             *
             * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.
             * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
             * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
             *
             * # <weight>
             * ## Weight
             * - `O(B + M + P1 + P2)` where:
             * - `B` is `proposal` size in bytes (length-fee-bounded)
             * - `M` is members-count (code- and governance-bounded)
             * - `P1` is the complexity of `proposal` preimage.
             * - `P2` is proposal-count (code-bounded)
             * - DB:
             * - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
             * - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)
             * - any mutations done while executing `proposal` (`P1`)
             * - up to 3 events
             * # </weight>
             **/
            close: AugmentedSubmittable<(proposalHash: Hash | string | Uint8Array, index: Compact<ProposalIndex> | AnyNumber | Uint8Array, proposalWeightBound: Compact<Weight> | AnyNumber | Uint8Array, lengthBound: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash, Compact<ProposalIndex>, Compact<Weight>, Compact<u32>]>;
            /**
             * Disapprove a proposal, close, and remove it from the system, regardless of its current state.
             *
             * Must be called by the Root origin.
             *
             * Parameters:
             * * `proposal_hash`: The hash of the proposal that should be disapproved.
             *
             * # <weight>
             * Complexity: O(P) where P is the number of max proposals
             * DB Weight:
             * * Reads: Proposals
             * * Writes: Voting, Proposals, ProposalOf
             * # </weight>
             **/
            disapproveProposal: AugmentedSubmittable<(proposalHash: Hash | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash]>;
            /**
             * Dispatch a proposal from a member using the `Member` origin.
             *
             * Origin must be a member of the collective.
             *
             * # <weight>
             * ## Weight
             * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
             * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
             * - 1 event
             * # </weight>
             **/
            execute: AugmentedSubmittable<(proposal: Proposal | {
                callIndex?: any;
                args?: any;
            } | string | Uint8Array, lengthBound: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Proposal, Compact<u32>]>;
            /**
             * Add a new proposal to either be voted on or executed directly.
             *
             * Requires the sender to be member.
             *
             * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
             * or put up for voting.
             *
             * # <weight>
             * ## Weight
             * - `O(B + M + P1)` or `O(B + M + P2)` where:
             * - `B` is `proposal` size in bytes (length-fee-bounded)
             * - `M` is members-count (code- and governance-bounded)
             * - branching is influenced by `threshold` where:
             * - `P1` is proposal execution complexity (`threshold < 2`)
             * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
             * - DB:
             * - 1 storage read `is_member` (codec `O(M)`)
             * - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
             * - DB accesses influenced by `threshold`:
             * - EITHER storage accesses done by `proposal` (`threshold < 2`)
             * - OR proposal insertion (`threshold <= 2`)
             * - 1 storage mutation `Proposals` (codec `O(P2)`)
             * - 1 storage mutation `ProposalCount` (codec `O(1)`)
             * - 1 storage write `ProposalOf` (codec `O(B)`)
             * - 1 storage write `Voting` (codec `O(M)`)
             * - 1 event
             * # </weight>
             **/
            propose: AugmentedSubmittable<(threshold: Compact<MemberCount> | AnyNumber | Uint8Array, proposal: Proposal | {
                callIndex?: any;
                args?: any;
            } | string | Uint8Array, lengthBound: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<MemberCount>, Proposal, Compact<u32>]>;
            /**
             * Set the collective's membership.
             *
             * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
             * - `prime`: The prime member whose vote sets the default.
             * - `old_count`: The upper bound for the previous number of members in storage.
             * Used for weight estimation.
             *
             * Requires root origin.
             *
             * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
             * the weight estimations rely on it to estimate dispatchable weight.
             *
             * # <weight>
             * ## Weight
             * - `O(MP + N)` where:
             * - `M` old-members-count (code- and governance-bounded)
             * - `N` new-members-count (code- and governance-bounded)
             * - `P` proposals-count (code-bounded)
             * - DB:
             * - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members
             * - 1 storage read (codec `O(P)`) for reading the proposals
             * - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal
             * - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one
             * # </weight>
             **/
            setMembers: AugmentedSubmittable<(newMembers: Vec<AccountId> | (AccountId | string | Uint8Array)[], prime: Option<AccountId> | null | object | string | Uint8Array, oldCount: MemberCount | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Vec<AccountId>, Option<AccountId>, MemberCount]>;
            /**
             * Add an aye or nay vote for the sender to the given proposal.
             *
             * Requires the sender to be a member.
             *
             * Transaction fees will be waived if the member is voting on any particular proposal
             * for the first time and the call is successful. Subsequent vote changes will charge a fee.
             * # <weight>
             * ## Weight
             * - `O(M)` where `M` is members-count (code- and governance-bounded)
             * - DB:
             * - 1 storage read `Members` (codec `O(M)`)
             * - 1 storage mutation `Voting` (codec `O(M)`)
             * - 1 event
             * # </weight>
             **/
            vote: AugmentedSubmittable<(proposal: Hash | string | Uint8Array, index: Compact<ProposalIndex> | AnyNumber | Uint8Array, approve: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash, Compact<ProposalIndex>, bool]>;
        };
        technicalMembership: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Add a member `who` to the set.
             *
             * May only be called from `T::AddOrigin`.
             **/
            addMember: AugmentedSubmittable<(who: AccountId | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId]>;
            /**
             * Swap out the sending member for some other key `new`.
             *
             * May only be called from `Signed` origin of a current member.
             *
             * Prime membership is passed from the origin account to `new`, if extant.
             **/
            changeKey: AugmentedSubmittable<(updated: AccountId | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId]>;
            /**
             * Remove the prime member if it exists.
             *
             * May only be called from `T::PrimeOrigin`.
             **/
            clearPrime: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            /**
             * Remove a member `who` from the set.
             *
             * May only be called from `T::RemoveOrigin`.
             **/
            removeMember: AugmentedSubmittable<(who: AccountId | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId]>;
            /**
             * Change the membership to a new set, disregarding the existing membership. Be nice and
             * pass `members` pre-sorted.
             *
             * May only be called from `T::ResetOrigin`.
             **/
            resetMembers: AugmentedSubmittable<(members: Vec<AccountId> | (AccountId | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<AccountId>]>;
            /**
             * Set the prime member. Must be a current member.
             *
             * May only be called from `T::PrimeOrigin`.
             **/
            setPrime: AugmentedSubmittable<(who: AccountId | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId]>;
            /**
             * Swap out one member `remove` for another `add`.
             *
             * May only be called from `T::SwapOrigin`.
             *
             * Prime membership is *not* passed from `remove` to `add`, if extant.
             **/
            swapMember: AugmentedSubmittable<(remove: AccountId | string | Uint8Array, add: AccountId | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [AccountId, AccountId]>;
        };
        timestamp: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Set the current time.
             *
             * This call should be invoked exactly once per block. It will panic at the finalization
             * phase, if this call hasn't been invoked by that time.
             *
             * The timestamp should be greater than the previous one by the amount specified by
             * `MinimumPeriod`.
             *
             * The dispatch origin for this call must be `Inherent`.
             *
             * # <weight>
             * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
             * - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in `on_finalize`)
             * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
             * # </weight>
             **/
            set: AugmentedSubmittable<(now: Compact<Moment> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<Moment>]>;
        };
        treasury: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Accept the curator role for a bounty.
             * A deposit will be reserved from curator and refund upon successful payout.
             *
             * May only be called from the curator.
             *
             * # <weight>
             * - O(1).
             * - Limited storage reads.
             * - One DB change.
             * # </weight>
             **/
            acceptCurator: AugmentedSubmittable<(bountyId: Compact<ProposalIndex> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<ProposalIndex>]>;
            /**
             * Approve a bounty proposal. At a later time, the bounty will be funded and become active
             * and the original deposit will be returned.
             *
             * May only be called from `T::ApproveOrigin`.
             *
             * # <weight>
             * - O(1).
             * - Limited storage reads.
             * - One DB change.
             * # </weight>
             **/
            approveBounty: AugmentedSubmittable<(bountyId: Compact<ProposalIndex> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<ProposalIndex>]>;
            /**
             * Approve a proposal. At a later time, the proposal will be allocated to the beneficiary
             * and the original deposit will be returned.
             *
             * May only be called from `T::RejectOrigin`.
             *
             * # <weight>
             * - Complexity: O(1).
             * - DbReads: `Proposals`, `Approvals`
             * - DbWrite: `Approvals`
             * # </weight>
             **/
            approveProposal: AugmentedSubmittable<(proposalId: Compact<ProposalIndex> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<ProposalIndex>]>;
            /**
             * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds after a delay.
             *
             * The dispatch origin for this call must be the curator of this bounty.
             *
             * - `bounty_id`: Bounty ID to award.
             * - `beneficiary`: The beneficiary account whom will receive the payout.
             **/
            awardBounty: AugmentedSubmittable<(bountyId: Compact<ProposalIndex> | AnyNumber | Uint8Array, beneficiary: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<ProposalIndex>, LookupSource]>;
            /**
             * Claim the payout from an awarded bounty after payout delay.
             *
             * The dispatch origin for this call must be the beneficiary of this bounty.
             *
             * - `bounty_id`: Bounty ID to claim.
             **/
            claimBounty: AugmentedSubmittable<(bountyId: Compact<BountyIndex> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<BountyIndex>]>;
            /**
             * Cancel a proposed or active bounty. All the funds will be sent to treasury and
             * the curator deposit will be unreserved if possible.
             *
             * Only `T::RejectOrigin` is able to cancel a bounty.
             *
             * - `bounty_id`: Bounty ID to cancel.
             **/
            closeBounty: AugmentedSubmittable<(bountyId: Compact<BountyIndex> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<BountyIndex>]>;
            /**
             * Close and payout a tip.
             *
             * The dispatch origin for this call must be _Signed_.
             *
             * The tip identified by `hash` must have finished its countdown period.
             *
             * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
             * as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
             *
             * # <weight>
             * - Complexity: `O(T)` where `T` is the number of tippers.
             * decoding `Tipper` vec of length `T`.
             * `T` is charged as upper bound given by `ContainsLengthBound`.
             * The actual cost depends on the implementation of `T::Tippers`.
             * - DbReads: `Tips`, `Tippers`, `tip finder`
             * - DbWrites: `Reasons`, `Tips`, `Tippers`, `tip finder`
             * # </weight>
             **/
            closeTip: AugmentedSubmittable<(hash: Hash | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash]>;
            /**
             * Extend the expiry time of an active bounty.
             *
             * The dispatch origin for this call must be the curator of this bounty.
             *
             * - `bounty_id`: Bounty ID to extend.
             * - `remark`: additional information.
             **/
            extendBountyExpiry: AugmentedSubmittable<(bountyId: Compact<BountyIndex> | AnyNumber | Uint8Array, remark: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<BountyIndex>, Bytes]>;
            /**
             * Propose a new bounty.
             *
             * The dispatch origin for this call must be _Signed_.
             *
             * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
             * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
             * or slashed when rejected.
             *
             * - `curator`: The curator account whom will manage this bounty.
             * - `fee`: The curator fee.
             * - `value`: The total payment amount of this bounty, curator fee included.
             * - `description`: The description of this bounty.
             **/
            proposeBounty: AugmentedSubmittable<(value: Compact<RingBalance> | AnyNumber | Uint8Array, description: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<RingBalance>, Bytes]>;
            /**
             * Assign a curator to a funded bounty.
             *
             * May only be called from `T::ApproveOrigin`.
             *
             * # <weight>
             * - O(1).
             * - Limited storage reads.
             * - One DB change.
             * # </weight>
             **/
            proposeCurator: AugmentedSubmittable<(bountyId: Compact<ProposalIndex> | AnyNumber | Uint8Array, curator: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, fee: Compact<RingBalance> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<ProposalIndex>, LookupSource, Compact<RingBalance>]>;
            /**
             * Put forward a suggestion for spending. A deposit proportional to the value
             * is reserved and slashed if the proposal is rejected. It is returned once the
             * proposal is awarded.
             *
             * # <weight>
             * - Complexity: O(1)
             * - DbReads: `ProposalCount`, `origin account`
             * - DbWrites: `ProposalCount`, `Proposals`, `origin account`
             * # </weight>
             **/
            proposeSpend: AugmentedSubmittable<(ringValue: Compact<RingBalance> | AnyNumber | Uint8Array, ktonValue: Compact<KtonBalance> | AnyNumber | Uint8Array, beneficiary: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<RingBalance>, Compact<KtonBalance>, LookupSource]>;
            /**
             * Reject a proposed spend. The original deposit will be slashed.
             *
             * May only be called from `T::RejectOrigin`.
             *
             * # <weight>
             * - Complexity: O(1)
             * - DbReads: `Proposals`, `rejected proposer account`
             * - DbWrites: `Proposals`, `rejected proposer account`
             * # </weight>
             **/
            rejectProposal: AugmentedSubmittable<(proposalId: Compact<ProposalIndex> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<ProposalIndex>]>;
            /**
             * Report something `reason` that deserves a tip and claim any eventual the finder's fee.
             *
             * The dispatch origin for this call must be _Signed_.
             *
             * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
             * `DataDepositPerByte` for each byte in `reason`.
             *
             * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
             * a UTF-8-encoded URL.
             * - `who`: The account which should be credited for the tip.
             *
             * Emits `NewTip` if successful.
             *
             * # <weight>
             * - Complexity: `O(R)` where `R` length of `reason`.
             * - encoding and hashing of 'reason'
             * - DbReads: `Reasons`, `Tips`
             * - DbWrites: `Reasons`, `Tips`
             * # </weight>
             **/
            reportAwesome: AugmentedSubmittable<(reason: Bytes | string | Uint8Array, who: AccountId | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes, AccountId]>;
            /**
             * Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.
             *
             * If successful, the original deposit will be unreserved.
             *
             * The dispatch origin for this call must be _Signed_ and the tip identified by `hash`
             * must have been reported by the signing account through `report_awesome` (and not
             * through `tip_new`).
             *
             * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
             * as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
             *
             * Emits `TipRetracted` if successful.
             *
             * # <weight>
             * - Complexity: `O(1)`
             * - Depends on the length of `T::Hash` which is fixed.
             * - DbReads: `Tips`, `origin account`
             * - DbWrites: `Reasons`, `Tips`, `origin account`
             * # </weight>
             **/
            retractTip: AugmentedSubmittable<(hash: Hash | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash]>;
            /**
             * Declare a tip value for an already-open tip.
             *
             * The dispatch origin for this call must be _Signed_ and the signing account must be a
             * member of the `Tippers` set.
             *
             * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
             * as the hash of the tuple of the hash of the original tip `reason` and the beneficiary
             * account ID.
             * - `tip_value`: The amount of tip that the sender would like to give. The median tip
             * value of active tippers will be given to the `who`.
             *
             * Emits `TipClosing` if the threshold of tippers has been reached and the countdown period
             * has started.
             *
             * # <weight>
             * - Complexity: `O(T)` where `T` is the number of tippers.
             * decoding `Tipper` vec of length `T`, insert tip and check closing,
             * `T` is charged as upper bound given by `ContainsLengthBound`.
             * The actual cost depends on the implementation of `T::Tippers`.
             *
             * Actually weight could be lower as it depends on how many tips are in `OpenTip` but it
             * is weighted as if almost full i.e of length `T-1`.
             * - DbReads: `Tippers`, `Tips`
             * - DbWrites: `Tips`
             * # </weight>
             **/
            tip: AugmentedSubmittable<(hash: Hash | string | Uint8Array, tipValue: Compact<RingBalance> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Hash, Compact<RingBalance>]>;
            /**
             * Give a tip for something new; no finder's fee will be taken.
             *
             * The dispatch origin for this call must be _Signed_ and the signing account must be a
             * member of the `Tippers` set.
             *
             * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
             * a UTF-8-encoded URL.
             * - `who`: The account which should be credited for the tip.
             * - `tip_value`: The amount of tip that the sender would like to give. The median tip
             * value of active tippers will be given to the `who`.
             *
             * Emits `NewTip` if successful.
             *
             * # <weight>
             * - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
             * - `O(T)`: decoding `Tipper` vec of length `T`
             * `T` is charged as upper bound given by `ContainsLengthBound`.
             * The actual cost depends on the implementation of `T::Tippers`.
             * - `O(R)`: hashing and encoding of reason of length `R`
             * - DbReads: `Tippers`, `Reasons`
             * - DbWrites: `Reasons`, `Tips`
             * # </weight>
             **/
            tipNew: AugmentedSubmittable<(reason: Bytes | string | Uint8Array, who: AccountId | string | Uint8Array, tipValue: Compact<RingBalance> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes, AccountId, Compact<RingBalance>]>;
            /**
             * Unassign curator from a bounty.
             *
             * This function can only be called by the `RejectOrigin` a signed origin.
             *
             * If this function is called by the `RejectOrigin`, we assume that the curator is malicious
             * or inactive. As a result, we will slash the curator when possible.
             *
             * If the origin is the curator, we take this as a sign they are unable to do their job and
             * they willingly give up. We could slash them, but for now we allow them to recover their
             * deposit and exit without issue. (We may want to change this if it is abused.)
             *
             * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
             * anyone in the community to call out that a curator is not doing their due diligence, and
             * we should pick a new curator. In this case the curator should also be slashed.
             *
             * # <weight>
             * - O(1).
             * - Limited storage reads.
             * - One DB change.
             * # </weight>
             **/
            unassignCurator: AugmentedSubmittable<(bountyId: Compact<ProposalIndex> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<ProposalIndex>]>;
        };
        vesting: {
            [key: string]: SubmittableExtrinsicFunction<ApiType>;
            /**
             * Force a vested transfer.
             *
             * The dispatch origin for this call must be _Root_.
             *
             * - `source`: The account whose funds should be transferred.
             * - `target`: The account that should be transferred the vested funds.
             * - `amount`: The amount of funds to transfer and will be vested.
             * - `schedule`: The vesting schedule attached to the transfer.
             *
             * Emits `VestingCreated`.
             *
             * # <weight>
             * - `O(1)`.
             * - DbWeight: 4 Reads, 4 Writes
             * - Reads: Vesting Storage, Balances Locks, Target Account, Source Account
             * - Writes: Vesting Storage, Balances Locks, Target Account, Source Account
             * # </weight>
             **/
            forceVestedTransfer: AugmentedSubmittable<(source: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, target: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, schedule: VestingInfo | {
                locked?: any;
                perBlock?: any;
                startingBlock?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [LookupSource, LookupSource, VestingInfo]>;
            /**
             * Unlock any vested funds of the sender account.
             *
             * The dispatch origin for this call must be _Signed_ and the sender must have funds still
             * locked under this module.
             *
             * Emits either `VestingCompleted` or `VestingUpdated`.
             *
             * # <weight>
             * - `O(1)`.
             * - DbWeight: 2 Reads, 2 Writes
             * - Reads: Vesting Storage, Balances Locks, [Sender Account]
             * - Writes: Vesting Storage, Balances Locks, [Sender Account]
             * # </weight>
             **/
            vest: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
            /**
             * Unlock any vested funds of a `target` account.
             *
             * The dispatch origin for this call must be _Signed_.
             *
             * - `target`: The account whose vested funds should be unlocked. Must have funds still
             * locked under this module.
             *
             * Emits either `VestingCompleted` or `VestingUpdated`.
             *
             * # <weight>
             * - `O(1)`.
             * - DbWeight: 3 Reads, 3 Writes
             * - Reads: Vesting Storage, Balances Locks, Target Account
             * - Writes: Vesting Storage, Balances Locks, Target Account
             * # </weight>
             **/
            vestOther: AugmentedSubmittable<(target: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [LookupSource]>;
            /**
             * Create a vested transfer.
             *
             * The dispatch origin for this call must be _Signed_.
             *
             * - `target`: The account that should be transferred the vested funds.
             * - `amount`: The amount of funds to transfer and will be vested.
             * - `schedule`: The vesting schedule attached to the transfer.
             *
             * Emits `VestingCreated`.
             *
             * # <weight>
             * - `O(1)`.
             * - DbWeight: 3 Reads, 3 Writes
             * - Reads: Vesting Storage, Balances Locks, Target Account, [Sender Account]
             * - Writes: Vesting Storage, Balances Locks, Target Account, [Sender Account]
             * # </weight>
             **/
            vestedTransfer: AugmentedSubmittable<(target: LookupSource | {
                Id: any;
            } | {
                Index: any;
            } | {
                Raw: any;
            } | {
                Address32: any;
            } | {
                Address20: any;
            } | string | Uint8Array, schedule: VestingInfo | {
                locked?: any;
                perBlock?: any;
                startingBlock?: any;
            } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [LookupSource, VestingInfo]>;
        };
    }
    interface SubmittableExtrinsics<ApiType extends ApiTypes> extends AugmentedSubmittables<ApiType> {
        (extrinsic: Call | Extrinsic | Uint8Array | string): SubmittableExtrinsic<ApiType>;
        [key: string]: SubmittableModuleExtrinsics<ApiType>;
    }
}
